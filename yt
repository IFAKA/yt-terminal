#!/bin/bash
# YouTube terminal browser with detailed progress and thumbnails

set -o pipefail

VERSION="1.0.0"

# Spinner for loading states
show_spinner() {
    local pid=$1
    local message=$2
    local spinstr='-\|/'
    local i=0

    if [ -t 1 ]; then
        tput civis 2>/dev/null
        while kill -0 "$pid" 2>/dev/null; do
            printf "\r%s %c" "$message" "${spinstr:i++%4:1}"
            sleep 0.1
        done
        tput cnorm 2>/dev/null
        printf "\r%s  \n" "$message"
    else
        echo "$message"
        wait "$pid"
    fi
}



# Default configuration
DEFAULT_NUM_RESULTS=10
DEFAULT_MAX_QUALITY=1080
DEFAULT_TIMEOUT=90
DEFAULT_VOLUME=100
DEFAULT_CACHE_DIR="$HOME/.cache/yt-thumbnails"
DEFAULT_SEARCH_CACHE_DIR="$HOME/.cache/yt-search"
DEFAULT_PLAYLIST_CACHE_DIR="$HOME/.cache/yt-playlists"
DEFAULT_VIDEO_INFO_CACHE_DIR="$HOME/.cache/yt-video-info"
DEFAULT_CACHE_EXPIRY=3600  # 1 hour in seconds
CONFIG_DIR="$HOME/.config/yt"
CONFIG_FILE="$CONFIG_DIR/config"
COOKIES_FILE="$CONFIG_DIR/cookies.txt"
FIRST_RUN_FILE="$CONFIG_DIR/.first_run_complete"

# Accessibility settings
ACCESSIBILITY_MODE=${ACCESSIBILITY_MODE:-false}
HIGH_CONTRAST_MODE=${HIGH_CONTRAST_MODE:-false}
SCREEN_READER_MODE=${SCREEN_READER_MODE:-false}

# Load configuration
load_config() {
    # Set defaults
    NUM_RESULTS=${NUM_RESULTS:-$DEFAULT_NUM_RESULTS}
    MAX_QUALITY=${MAX_QUALITY:-$DEFAULT_MAX_QUALITY}
    TIMEOUT=${TIMEOUT:-$DEFAULT_TIMEOUT}
    VOLUME=${VOLUME:-$DEFAULT_VOLUME}
    CACHE_DIR=${CACHE_DIR:-$DEFAULT_CACHE_DIR}
    SEARCH_CACHE_DIR=${SEARCH_CACHE_DIR:-$DEFAULT_SEARCH_CACHE_DIR}
    PLAYLIST_CACHE_DIR=${PLAYLIST_CACHE_DIR:-$DEFAULT_PLAYLIST_CACHE_DIR}
    VIDEO_INFO_CACHE_DIR=${VIDEO_INFO_CACHE_DIR:-$DEFAULT_VIDEO_INFO_CACHE_DIR}
    CACHE_EXPIRY=${CACHE_EXPIRY:-$DEFAULT_CACHE_EXPIRY}
    
    # Create cache and config directories
    mkdir -p "$CACHE_DIR" "$SEARCH_CACHE_DIR" "$PLAYLIST_CACHE_DIR" "$VIDEO_INFO_CACHE_DIR" "$CONFIG_DIR" 2>/dev/null
    
    # Load user config if it exists
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
    
    # Auto-detect screen reader
    if command -v orca &> /dev/null || command -v espeak &> /dev/null || [ -n "$SCREEN_READER" ]; then
        SCREEN_READER_MODE=true
    fi
}

# Screen reader announcement
announce() {
    local message="$1"
    if [ "$SCREEN_READER_MODE" = "true" ]; then
        # Try different screen readers
        if command -v espeak &> /dev/null; then
            echo "$message" | espeak 2>/dev/null &
        elif command -v say &> /dev/null; then
            say "$message" 2>/dev/null &
        fi
    fi
    echo "$message" >&2
}

# ANSI Color codes for beautiful terminal output
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'

# Foreground colors (used throughout the script)
C_YELLOW='\033[38;5;226m'
C_GREEN='\033[38;5;46m'
C_CYAN='\033[38;5;51m'
C_PURPLE='\033[38;5;141m'
C_MAGENTA='\033[38;5;201m'
C_WHITE='\033[38;5;15m'
C_GRAY='\033[38;5;244m'

# YouTube brand colors
C_YT_RED='\033[38;5;196m'

# Minimal color scheme
get_fzf_colors() {
    if [ "$HIGH_CONTRAST_MODE" = "true" ]; then
        echo "fg:#ffffff,bg:#000000,hl:#ffffff,fg+:#ffffff,bg+:#1a1a1a,hl+:#ffffff,pointer:#ffffff,header:#888888,info:#888888"
    else
        echo "fg:#888888,bg:-1,hl:#ffffff,fg+:#ffffff,bg+:-1,hl+:#ffffff,pointer:#ffffff,header:#555555,info:#555555"
    fi
}

# Minimal fzf options
get_fzf_base_opts() {
    local colors
    colors=$(get_fzf_colors)
    echo "--layout=reverse --no-border --pointer=‚ñ∏ --marker=+ --no-separator --no-scrollbar --color=$colors --bind=j:down,k:up --bind=ctrl-d:half-page-down,ctrl-u:half-page-up --bind=ctrl-f:page-down,ctrl-b:page-up"
}

# Simplified box drawing functions
draw_border() {
    local type="$1"  # top, bottom, middle
    local width="${2:-80}"
    local char="‚ïê"
    [ "$type" = "top" ] && echo -e "${C_YT_RED}‚ïî$(printf "${char}%.0s" $(seq 1 $((width - 2))))‚ïó${C_RESET}"
    [ "$type" = "bottom" ] && echo -e "${C_YT_RED}‚ïö$(printf "${char}%.0s" $(seq 1 $((width - 2))))‚ïù${C_RESET}"
    [ "$type" = "middle" ] && echo -e "${C_YT_RED}‚ï†$(printf "${char}%.0s" $(seq 1 $((width - 2))))‚ï£${C_RESET}"
}

print_box_line() {
    local text="$1"
    local width="${2:-78}"
    local color="${3:-$C_WHITE}"
    # Strip ANSI for length calculation
    local stripped
    stripped=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local padding=$(( (width - ${#stripped}) / 2 ))
    local right_padding=$(( width - ${#stripped} - padding ))
    printf "${C_YT_RED}‚ïë${C_RESET}%*s${color}%b${C_RESET}%*s${C_YT_RED}‚ïë${C_RESET}\n" "$padding" "" "$text" "$right_padding" ""
}

# Get the default browser on macOS
get_default_browser() {
    local default_browser=""
    
    # Only works on macOS
    if [ "$(uname -s)" != "Darwin" ]; then
        echo ""
        return
    fi
    
    # Try to get default browser from LaunchServices using Python
    local bundle_id
    bundle_id=$(python3 -c "
import plistlib
import os
import sys

plist_path = os.path.expanduser('~/Library/Preferences/com.apple.LaunchServices/com.apple.launchservices.secure.plist')
try:
    with open(plist_path, 'rb') as f:
        plist = plistlib.load(f)
    
    handlers = plist.get('LSHandlers', [])
    for handler in handlers:
        if handler.get('LSHandlerURLScheme') == 'https':
            bundle_id = handler.get('LSHandlerRoleAll', '')
            if bundle_id:
                print(bundle_id)
                break
except:
    pass
" 2>/dev/null)
    
    # Map bundle IDs to browser names
    case "$bundle_id" in
        *brave*)
            default_browser="brave"
            ;;
        *firefox*)
            default_browser="firefox"
            ;;
        *chrome*|*chromium*)
            default_browser="chrome"
            ;;
        *safari*)
            default_browser="safari"
            ;;
        *edge*)
            default_browser="edge"
            ;;
    esac
    
    echo "$default_browser"
}

# Detect available browsers
detect_browsers() {
    local available=()
    for browser in brave firefox chrome safari edge; do
        timeout 20 yt-dlp --cookies-from-browser "$browser" --simulate "ytsearch1:test" &>/dev/null && available+=("$browser")
    done
    echo "${available[@]}"
}

# Setup authentication for personal content
setup_authentication() {
    clear
    draw_border top 80
    print_box_line "" 78
    print_box_line "üîê  AUTHENTICATION SETUP" 78 "$C_BOLD$C_CYAN"
    print_box_line "" 78
    draw_border middle 80
    print_box_line "" 78
    print_box_line "To access personal content (subscriptions, playlists, etc.)," 78 "$C_WHITE"
    print_box_line "we need to use cookies from your browser." 78 "$C_WHITE"
    print_box_line "" 78
    print_box_line "This is safe and automatic - no passwords needed!" 78 "$C_GREEN"
    print_box_line "" 78
    draw_border bottom 80
    echo ""
    
    echo "Detecting browsers (this may take up to a minute)..."
    echo ""
    
    # Detect available browsers
    local available_browsers
    IFS=' ' read -r -a available_browsers <<< "$(detect_browsers)"
    
    if [ ${#available_browsers[@]} -eq 0 ]; then
        echo "error:No supported browsers detected."
        echo ""
        echo "Supported browsers: Brave, Firefox, Chrome, Safari, Edge"
        echo ""
        echo "Common issues:"
        echo "  1. Browser is currently running (must be CLOSED)"
        echo "  2. Not logged into YouTube in any browser"
        echo ""
        echo "Try these steps:"
        echo "  1. Close ALL browsers completely"
        echo "  2. Open ONE browser (e.g., Brave or Chrome)"
        echo "  3. Go to youtube.com and log in"
        echo "  4. Close the browser"
        echo "  5. Run: yt --setup-auth"
        echo ""
        return 1
    fi
    
    echo "Detected browsers:"
    for i in "${!available_browsers[@]}"; do
        echo "  $((i+1)). ${available_browsers[$i]}"
    done
    echo ""
    
    # Check if default browser is missing and provide helpful message
    local default_browser
    default_browser=$(get_default_browser)
    if [ -n "$default_browser" ]; then
        local default_found=false
        for browser in "${available_browsers[@]}"; do
            if [ "$browser" = "$default_browser" ]; then
                default_found=true
                break
            fi
        done
        
        if [ "$default_found" = false ]; then
            echo "Note: Your default browser ($default_browser) was not detected."
            echo "   This usually means:"
            echo "   ‚Ä¢ $default_browser is currently running (close it and try again)"
            echo "   ‚Ä¢ You're not logged into YouTube in $default_browser"
            echo "   ‚Ä¢ $default_browser uses cookie encryption (requires browser to be closed)"
            echo ""
        fi
    fi
    
    # Auto-select browser
    local browser_choice
    if [ ${#available_browsers[@]} -eq 1 ]; then
        browser_choice="${available_browsers[0]}"
        local is_default=false
        local default_browser
        default_browser=$(get_default_browser)
        if [ "$browser_choice" = "$default_browser" ]; then
            is_default=true
        fi
        
        if [ "$is_default" = true ]; then
            echo "Using ${browser_choice} (your default browser)"
        else
            echo "Using ${browser_choice} (only browser with accessible cookies)"
        fi
    else
        # Try to use the system's default browser
        local default_browser
        default_browser=$(get_default_browser)
        local default_found=false
        
        if [ -n "$default_browser" ]; then
            for browser in "${available_browsers[@]}"; do
                if [ "$browser" = "$default_browser" ]; then
                    default_found=true
                    break
                fi
            done
        fi
        
        if [ "$default_found" = true ]; then
            browser_choice="$default_browser"
            echo "Using ${browser_choice} (system default browser)"
        else
            # Fall back to Brave if available
            local brave_found=false
            for browser in "${available_browsers[@]}"; do
                if [ "$browser" = "brave" ]; then
                    brave_found=true
                    break
                fi
            done
            
            if [ "$brave_found" = true ]; then
                browser_choice="brave"
                echo "Using ${browser_choice} (fallback)"
            else
                echo -n "Choose browser [1-${#available_browsers[@]}]: "
                read -r choice
                
                if [ -z "$choice" ] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#available_browsers[@]} ]; then
                    echo "error:Invalid choice"
                    return 1
                fi
                
                browser_choice="${available_browsers[$((choice-1))]}"
            fi
        fi
    fi
    
    echo ""
    echo "Testing authentication with ${browser_choice}..."
    
    # Test if we can extract cookies
    local test_output
    test_output=$(mktemp)
    if ! timeout 20 yt-dlp --cookies-from-browser "$browser_choice" --simulate "ytsearch1:test" 2>"$test_output" >/dev/null; then
        echo "error:Failed to extract cookies from ${browser_choice}"
        echo ""
        
        # Show error if helpful
        if [ -s "$test_output" ]; then
            echo "Error:"
            grep -i "error\|warning\|failed" "$test_output" | head -3 | sed 's/^/  /'
            echo ""
        fi
        
        echo "Make sure:"
        echo "  1. You're logged into YouTube in ${browser_choice}"
        echo "  2. ${browser_choice} is COMPLETELY CLOSED (not just minimized)"
        echo "  3. Try closing ${browser_choice}, waiting 5 seconds, then run this again"
        echo ""
        rm -f "$test_output"
        return 1
    fi
    rm -f "$test_output"
    
    # Export cookies to file to avoid repeated password prompts
    echo ""
    echo "Exporting cookies to file (you may be asked for your password once)..."
    
    # Remove old cookies file
    rm -f "$COOKIES_FILE"
    
    # Export cookies from browser
    if timeout 30 yt-dlp --cookies-from-browser "$browser_choice" --cookies "$COOKIES_FILE" --simulate "ytsearch1:test" &>/dev/null; then
        echo "Cookies exported successfully"
        
        # Save to config
        {
            echo ""
            echo "# Authentication (auto-configured)"
            echo "AUTH_METHOD=\"cookies\""
            echo "BROWSER=\"$browser_choice\""
        } >> "$CONFIG_FILE"
    else
        echo "warning:Cookie export failed - will use browser cookies directly"
        echo "   (You may be asked for your password on each use)"
        
        # Save to config without cookie file
        {
            echo ""
            echo "# Authentication (auto-configured)"
            echo "AUTH_METHOD=\"browser\""
            echo "BROWSER=\"$browser_choice\""
        } >> "$CONFIG_FILE"
    fi
    
    # Reload config
    load_config
    
    echo ""
    :
    echo "done:Authentication configured!"
    :
    echo ""
    echo "Using: ${browser_choice} cookies"
    echo "Saved to: $CONFIG_FILE"
    echo ""
    
    return 0
}

# Get authentication arguments for yt-dlp
get_auth_args() {
    # Check if authentication is configured
    if [ -z "$BROWSER" ]; then
        # Not configured - run setup
        if ! setup_authentication; then
            return 1
        fi
    fi
    
    # Return the auth argument based on method
    if [ "$AUTH_METHOD" = "cookies" ] && [ -f "$COOKIES_FILE" ]; then
        # Use exported cookie file (no password prompt)
        echo "--cookies $COOKIES_FILE"
    else
        # Use browser cookies directly (may prompt for password)
        echo "--cookies-from-browser $BROWSER"
    fi
    return 0
}

# Generate cache key from search term
get_cache_key() {
    local search_term="$1"
    local search_type="$2"  # "video" or "playlist"
    echo "${search_type}_$(echo -n "$search_term" | md5)"
}

# Check if cache is valid (not expired)
is_cache_valid() {
    local cache_file="$1"
    
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    local current_time
    current_time=$(date +%s)
    local file_time
    file_time=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)
    local age=$((current_time - file_time))
    
    if [ "$age" -lt "$CACHE_EXPIRY" ]; then
        return 0
    else
        return 1
    fi
}

# Cleanup function for temp files
cleanup() {
    local exit_code=$?
    if [ -n "$tmpfile" ] && [ -f "$tmpfile" ]; then
        rm -f "$tmpfile"
    fi
    exit "$exit_code"
}

trap cleanup EXIT INT TERM

# Detect platform
detect_platform() {
    local os
    os=$(uname -s)
    
    case "$os" in
        Linux*)
            if grep -qi microsoft /proc/version 2>/dev/null; then
                echo "WSL"
            else
                echo "Linux"
            fi
            ;;
        Darwin*)
            echo "macOS"
            ;;
        MINGW*|MSYS*|CYGWIN*)
            echo "Windows"
            ;;
        *)
            echo "Unknown"
            ;;
    esac
}

# Get clipboard content cross-platform
get_clipboard_content() {
    local platform
    platform=$(detect_platform)

    case "$platform" in
        macOS)
            pbpaste 2>/dev/null
            ;;
        Linux)
            if command -v xclip &> /dev/null; then
                xclip -selection clipboard -o 2>/dev/null
            elif command -v xsel &> /dev/null; then
                xsel --clipboard --output 2>/dev/null
            elif command -v wl-paste &> /dev/null; then
                wl-paste 2>/dev/null
            fi
            ;;
        WSL)
            powershell.exe -command "Get-Clipboard" 2>/dev/null | tr -d '\r'
            ;;
        Windows)
            powershell.exe -command "Get-Clipboard" 2>/dev/null | tr -d '\r'
            ;;
    esac
}

# Check if text is a valid YouTube URL
is_youtube_url() {
    local text="$1"
    [[ "$text" =~ ^https?://(www\.)?(youtube\.com|youtu\.be|music\.youtube\.com)/ ]]
}

# Get YouTube URL from clipboard if valid
get_clipboard_youtube_url() {
    local clipboard_content
    clipboard_content=$(get_clipboard_content)

    if is_youtube_url "$clipboard_content"; then
        echo "$clipboard_content"
    fi
}

# Get package manager
get_package_manager() {
    local platform="$1"
    
    case "$platform" in
        macOS)
            if command -v brew &> /dev/null; then
                echo "brew"
            else
                echo "none"
            fi
            ;;
        Linux|WSL)
            if command -v apt &> /dev/null; then
                echo "apt"
            elif command -v dnf &> /dev/null; then
                echo "dnf"
            elif command -v pacman &> /dev/null; then
                echo "pacman"
            elif command -v zypper &> /dev/null; then
                echo "zypper"
            else
                echo "none"
            fi
            ;;
        Windows)
            if command -v choco &> /dev/null; then
                echo "choco"
            elif command -v scoop &> /dev/null; then
                echo "scoop"
            else
                echo "none"
            fi
            ;;
        *)
            echo "none"
            ;;
    esac
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    local optional_deps=()
    local platform
    local pkg_manager
    
    platform=$(detect_platform)
    pkg_manager=$(get_package_manager "$platform")
    
    # Required dependencies
    command -v yt-dlp &> /dev/null || missing_deps+=("yt-dlp")
    command -v mpv &> /dev/null || missing_deps+=("mpv")
    command -v fzf &> /dev/null || missing_deps+=("fzf")
    command -v jq &> /dev/null || missing_deps+=("jq")
    command -v curl &> /dev/null || missing_deps+=("curl")
    
    # Optional dependencies
    command -v chafa &> /dev/null || optional_deps+=("chafa")
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        :
        echo "error:Missing required dependencies"
        :
        echo ""
        echo "Please install the following:"
        for dep in "${missing_deps[@]}"; do
            echo "  ‚Ä¢ $dep"
        done
        echo ""
        echo "Detected platform: $platform"
        echo ""
        
        # Platform-specific installation instructions
        case "$pkg_manager" in
            brew)
                echo "Installation command (Homebrew):"
                echo "  brew install ${missing_deps[*]}"
                ;;
            apt)
                echo "Installation command (Debian/Ubuntu):"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
                
                if [ "$platform" = "WSL" ]; then
                    echo ""
                    echo "WSL Note: For video playback, you may need:"
                    echo "  ‚Ä¢ Windows mpv installed, or"
                    echo "  ‚Ä¢ X server (VcXsrv/Xming) for Linux GUI apps"
                fi
                ;;
            dnf)
                echo "Installation command (Fedora/RHEL):"
                echo "  sudo dnf install ${missing_deps[*]}"
                ;;
            pacman)
                echo "Installation command (Arch Linux):"
                echo "  sudo pacman -S ${missing_deps[*]}"
                ;;
            choco)
                echo "Installation command (Chocolatey):"
                echo "  choco install ${missing_deps[*]}"
                ;;
            scoop)
                echo "Installation command (Scoop):"
                echo "  scoop install ${missing_deps[*]}"
                ;;
            *)
                echo "Please install manually. Visit:"
                echo "  ‚Ä¢ yt-dlp: https://github.com/yt-dlp/yt-dlp#installation"
                echo "  ‚Ä¢ mpv: https://mpv.io/installation/"
                echo "  ‚Ä¢ fzf: https://github.com/junegunn/fzf#installation"
                echo "  ‚Ä¢ jq: https://stedolan.github.io/jq/download/"
                ;;
        esac
        echo ""
        return 1
    fi
    
    # Test if yt-dlp is working
    if ! timeout 10 yt-dlp --version &>/dev/null; then
        :
        echo "error:yt-dlp is not working properly"
        :
        echo ""
        echo "Try updating yt-dlp:"
        if command -v brew &> /dev/null; then
            echo "  brew upgrade yt-dlp"
        elif command -v pip3 &> /dev/null; then
            echo "  pip3 install --upgrade yt-dlp"
        elif command -v pip &> /dev/null; then
            echo "  pip install --upgrade yt-dlp"
        else
            echo "  Visit: https://github.com/yt-dlp/yt-dlp#installation"
        fi
        echo ""
        return 1
    fi
    
    if [ ${#optional_deps[@]} -ne 0 ]; then
        echo "Optional: Install 'chafa' for thumbnail previews"
        echo "   brew install chafa"
        echo ""
    fi
    
    return 0
}

# Show usage information
show_usage() {
    echo "Usage: yt [OPTIONS] <search term>"
    echo ""
    echo "Search Options:"
    echo "  -f, --first        Auto-play first search result"
    echo "  -a, --audio-only   Play audio only (no video)"
    echo "  -p, --playlist     Search for playlists instead of videos"
    echo "  --no-autoplay      Disable autoplay (autoplay is ON by default)"
    echo ""
    echo "  Note: Short flags can be combined in any order (e.g., -apf, -fap, -pfa)"
    echo ""
    echo "Personal Account:"
    echo "  --home             View personalized recommendations"
    echo "  --subs             Browse latest videos from subscriptions"
    echo "  --playlists        Access your playlists"
    echo "  --watch-later      View watch later queue"
    echo "  --liked            Browse liked videos"
    echo ""
    echo "Accessibility Options:"
    echo "  --high-contrast    Enable high contrast mode"
    echo "  --screen-reader    Enable screen reader announcements"
    echo "  --no-emojis        Disable emoji icons (cleaner for some readers)"
    echo ""
    echo "Other Options:"
    echo "  --clear-cache      Clear search and playlist cache"
    echo "  --setup-auth       Re-configure browser authentication"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "Examples:"
    echo "  yt lofi beats                # Search, select, then autoplay related videos"
    echo "  yt -f lofi hip hop           # Auto-play first result, then autoplay"
    echo "  yt -a music                  # Audio-only with autoplay"
    echo "  yt -p lofi playlists         # Browse & autoplay playlists"
    echo "  yt -apf study music          # Chained: audio + playlist + first result"
    echo "  yt --no-autoplay vim tutorial # Play once and exit (no autoplay)"
    echo "  yt <url>                     # Play video from URL"
    echo ""
    echo "  yt --subs                    # Latest from subscriptions"
    echo "  yt --home -a                 # Recommendations in audio-only mode"
    echo ""
    echo "While Playing:"
    echo "  Video mode: Press 'd' to view description/links (video keeps playing)"
    echo "  Audio mode: Full MPV controls (pause, skip, volume, etc.)"
    echo "  Subtitles:  Press 'j' in mpv to cycle subtitle tracks, 'v' to toggle visibility"
    echo "  Links can be opened in browser, copied, or selected multiple at once"
    echo ""
    echo "Autoplay:"
    echo "  Autoplay is ENABLED by default - videos/playlists continue automatically"
    echo "  After your selection plays, related content plays next (YouTube-style)"
    echo "  Press Ctrl+C during countdown to stop autoplay"
    echo ""
    echo "Authentication:"
    echo "  Personal features require browser cookies (Brave, Firefox, Chrome, etc.)"
    echo "  Setup runs automatically on first use - no passwords needed!"
    echo ""
    echo "Cache:"
    echo "  Search results are cached for $((CACHE_EXPIRY / 60)) minutes"
    echo "  Cache location: $SEARCH_CACHE_DIR"
    echo ""
    echo "Version: $VERSION"
    echo "Configuration file: $CONFIG_FILE"
}

# Clear cache
clear_cache() {
    :
    echo "clearing cache..."
    :
    echo ""
    
    local deleted=0
    
    if [ -d "$SEARCH_CACHE_DIR" ]; then
        local count
        count=$(find "$SEARCH_CACHE_DIR" -type f | wc -l | xargs)
        rm -rf "${SEARCH_CACHE_DIR:?}"/*
        deleted=$((deleted + count))
        echo "Cleared search cache ($count files)"
    fi
    
    if [ -d "$PLAYLIST_CACHE_DIR" ]; then
        local count
        count=$(find "$PLAYLIST_CACHE_DIR" -type f | wc -l | xargs)
        rm -rf "${PLAYLIST_CACHE_DIR:?}"/*
        deleted=$((deleted + count))
        echo "Cleared playlist cache ($count files)"
    fi
    
    if [ -d "$CACHE_DIR" ]; then
        local count
        count=$(find "$CACHE_DIR" -name "*.jpg" | wc -l | xargs)
        rm -rf "${CACHE_DIR:?}"/*.jpg
        deleted=$((deleted + count))
        echo "Cleared thumbnail cache ($count files)"
    fi
    
    if [ -d "$VIDEO_INFO_CACHE_DIR" ]; then
        local count
        count=$(find "$VIDEO_INFO_CACHE_DIR" -type f | wc -l | xargs)
        rm -rf "${VIDEO_INFO_CACHE_DIR:?}"/*
        deleted=$((deleted + count))
        echo "Cleared video info cache ($count files)"
    fi
    
    echo ""
    :
    echo "done:Cleared $deleted cached items"
    :
}

# Extract video ID from various YouTube URL formats
extract_video_id() {
    local url="$1"
    local video_id=""

    # Handle youtu.be/VIDEO_ID
    if [[ "$url" =~ youtu\.be/([a-zA-Z0-9_-]{11}) ]]; then
        video_id="${BASH_REMATCH[1]}"
    # Handle youtube.com/watch?v=VIDEO_ID
    elif [[ "$url" =~ [\?\&]v=([a-zA-Z0-9_-]{11}) ]]; then
        video_id="${BASH_REMATCH[1]}"
    # Handle youtube.com/embed/VIDEO_ID
    elif [[ "$url" =~ youtube\.com/embed/([a-zA-Z0-9_-]{11}) ]]; then
        video_id="${BASH_REMATCH[1]}"
    # Handle youtube.com/v/VIDEO_ID
    elif [[ "$url" =~ youtube\.com/v/([a-zA-Z0-9_-]{11}) ]]; then
        video_id="${BASH_REMATCH[1]}"
    fi

    echo "$video_id"
}

# Play video from URL - delegates to play_video for unified experience
play_url() {
    local url="$1"
    local audio_only="$2"

    # Extract video ID from URL
    local video_id
    video_id=$(extract_video_id "$url")

    if [ -z "$video_id" ]; then
        echo "error:Could not extract video ID from URL"
        echo "   Supported formats: youtube.com/watch?v=..., youtu.be/..., youtube.com/embed/..."
        return 1
    fi

    :
    echo "üì• Fetching video info..."
    :

    # Fetch title using yt-dlp
    local title
    title=$(yt-dlp --cookies "$COOKIE_FILE" --get-title "https://youtube.com/watch?v=$video_id" 2>/dev/null)

    if [ -z "$title" ]; then
        title="Video $video_id"
    fi

    # Construct "selected" format: "Title [channel] video_id"
    # play_video extracts video_id as last field and title as everything before [
    local selected="$title [] $video_id"

    # Delegate to play_video for unified experience (description, links, etc.)
    play_video "$selected" "$audio_only"
}

# Unified YouTube search - handles both videos and playlists
search_youtube() {
    local search_term="$1"
    local search_playlists="$2"
    local auto_first="$3"
    
    # Set search parameters based on type
    local content_type search_url
    if [ "$search_playlists" = "true" ]; then
        content_type="playlist"
        # URL-encode the search term
        local encoded_term
        encoded_term=$(echo "$search_term" | sed 's/ /+/g')
        search_url="https://www.youtube.com/results?search_query=${encoded_term}&sp=EgIQAw%253D%253D"
    else
        content_type="video"
        local num_to_fetch="$NUM_RESULTS"
        [ "$auto_first" = "true" ] && num_to_fetch=1
        search_url="ytsearch${num_to_fetch}:$search_term"
    fi

    clear
    echo ""
    echo "searching: $search_term"
    echo ""
    
    # Create temp file
    tmpfile=$(mktemp) || { echo "error:Failed to create temp file"; return 1; }
    
    # Determine how many results to fetch
    local num_to_fetch="$NUM_RESULTS"
    if [ "$auto_first" = "true" ]; then
        num_to_fetch=1
    fi
    
    # Check cache first
    local cache_key
    cache_key=$(get_cache_key "$search_term" "$content_type")
    local cache_file="$SEARCH_CACHE_DIR/$cache_key.json"
    
    if is_cache_valid "$cache_file"; then
        echo "(cached)"
        cp "$cache_file" "$tmpfile"
        return 0
    fi
    
    # Create temp file for raw JSON
    local jsonfile
    jsonfile=$(mktemp) || { echo "error:Failed to create temp file"; return 1; }
    
    # Fetch content
    local error_output
    error_output=$(mktemp)
    
    if [ "$search_playlists" = "true" ]; then
        echo "Searching playlists..."
        (
            timeout "$TIMEOUT" yt-dlp "$search_url" \
                --flat-playlist \
                --dump-json \
                --skip-download \
                --no-warnings \
                --quiet \
                --playlist-end "$num_to_fetch" \
                2>"$error_output" > "$jsonfile"
        ) &
    else
        echo "Searching YouTube..."
        (
            timeout "$TIMEOUT" yt-dlp "$search_url" \
                --dump-json \
                --skip-download \
                --no-warnings \
                --quiet \
                > "$jsonfile" 2>"$error_output"
        ) &
    fi
    local fetch_pid=$!
    
    # Show progress with count
    local progress_count=0
    local spinstr='-\|/'
    local i=0
    if [ -t 1 ]; then
        tput civis 2>/dev/null
        while kill -0 "$fetch_pid" 2>/dev/null; do
            if [ -f "$jsonfile" ]; then
                local count_raw
                count_raw=$(grep -c '^{' "$jsonfile" 2>/dev/null || echo "0")
                progress_count=$(echo "$count_raw" | head -1 | tr -cd '0-9' | grep -o '^[0-9]*' || echo "0")
                [ -z "$progress_count" ] && progress_count=0
                [ "$progress_count" -gt "$num_to_fetch" ] && progress_count="$num_to_fetch"
            fi
            printf "\r%c fetching %d/%d" "${spinstr:i++%4:1}" "$progress_count" "$num_to_fetch"
            sleep 0.2
        done
        tput cnorm 2>/dev/null
        printf "\r                              \n"
    else
        echo "fetching..."
        wait "$fetch_pid"
    fi
    
    wait "$fetch_pid" 2>/dev/null
    local fetch_result=$?
    
    if [ "$fetch_result" -ne 0 ]; then
        rm -f "$jsonfile"
        echo "error:Search failed or timed out"
        [ -s "$error_output" ] && echo "" && echo "Error details:" && head -3 "$error_output" | sed 's/^/  /' && echo ""
        echo "Troubleshooting steps:"
        echo "  1. Update yt-dlp (brew upgrade yt-dlp or pip install --upgrade yt-dlp)"
        echo "  2. Check your internet connection"
        echo "  3. Try a different search term"
        rm -f "$error_output"
        return 1
    fi
    
    rm -f "$error_output"
    
    # Parse and display results
    local count=0
    while IFS= read -r line && [ "$count" -lt "$num_to_fetch" ]; do
        if [ "$search_playlists" = "true" ]; then
            local playlist_title playlist_id thumbnail
            playlist_title=$(echo "$line" | jq -r '.title // "Unknown"')
            playlist_id=$(echo "$line" | jq -r '.id // ""')
            thumbnail=$(echo "$line" | jq -r '.thumbnails[0].url // ""')
            
            if [ -n "$playlist_id" ] && [ "$playlist_id" != "null" ]; then
                echo "$playlist_title"$'\t'"PL"$'\t'"$playlist_id"$'\t'"$thumbnail" >> "$tmpfile"
                count=$((count + 1))
                echo "  $count/$num_to_fetch: $(echo "$playlist_title" | cut -c1-50)..."
            fi
        else
            video_data=$(echo "$line" | jq -r '"\(.title)\t\(.duration_string // "LIVE")\t\(.id)\t\(.thumbnail)"')
            echo "$video_data" >> "$tmpfile"
            count=$((count + 1))
            echo "  $count/$num_to_fetch: $(echo "$line" | jq -r '.title' | cut -c1-50)..."
        fi
    done < "$jsonfile"
    
    rm -f "$jsonfile"
    echo ""
    
    if [ ! -s "$tmpfile" ] || [ "$count" -eq 0 ]; then
        echo "error:No ${content_type}s found!"
        return 1
    fi
    
    cp "$tmpfile" "$cache_file"
    return 0
}

# Download thumbnails
download_thumbnails() {
    local search_playlists="$1"
    results=""  # Initialize results variable
    mkdir -p "$CACHE_DIR" || { echo "error:Failed to create cache directory"; return 1; }
    
    while IFS=$'\t' read -r title duration id thumbnail; do
        if [ "$search_playlists" = "true" ]; then
            # Format playlist result line
            results="${results}$(printf "%-85s %s" "$title" "$id")"$'\n'
        else
            # Format video result line
            results="${results}$(printf "%-80s [%8s] %s" "$title" "$duration" "$id")"$'\n'
        fi
        
        # Download thumbnail in background for preview
        if [ -n "$thumbnail" ]; then
            curl -s "$thumbnail" -o "$CACHE_DIR/$id.jpg" 2>/dev/null &
        fi
    done < "$tmpfile"
    
    if [ -z "$results" ]; then
        :
        echo "error:No results found!"
        :
        return 1
    fi
    
    # Count actual non-empty lines
    items_count=$(echo "$results" | grep -c '^.')
    echo "fetched $items_count items"

    # Wait for thumbnails
    (sleep 2) &
    local sleep_pid=$!
    show_spinner "$sleep_pid" "loading thumbnails"
    wait "$sleep_pid"

    echo "ready"
    sleep 0.3
    
    return 0
}

# Preview playlist contents (for fzf preview)
preview_playlist() {
    local playlist_id="$1"
    
    :
    echo "playlist contents"
    echo ""

    # Check cache first
    local cache_file="$PLAYLIST_CACHE_DIR/$playlist_id.json"

    if is_cache_valid "$cache_file"; then
        echo "(cached)"
        echo ""
        
        # Read from cache
        local videos
        videos=$(cat "$cache_file")
        
        # Display first 20 videos
        local count=0
        while IFS= read -r line; do
            local video_title
            video_title=$(echo "$line" | jq -r '.title // "Unknown"')
            count=$((count + 1))
            printf "%2d. %s\n" "$count" "$video_title"
            [ "$count" -ge 20 ] && break
        done <<< "$videos"
        
        # Get total count
        local total_count
        total_count=$(echo "$videos" | wc -l | xargs)
        
        if [ "$total_count" -gt 20 ]; then
            echo ""
            echo "... and $((total_count - 20)) more videos"
        fi
        
        echo ""
        :
        echo "Total: $total_count videos in playlist"
        :
        return 0
    fi
    
    echo "Loading videos..."
    echo ""
    
    # Fetch first 20 videos from playlist
    local videos
    videos=$(timeout 10 yt-dlp "https://youtube.com/playlist?list=$playlist_id" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-end 20 \
        2>/dev/null)
    
    if [ -z "$videos" ]; then
        echo "error:Could not load playlist contents"
        return 1
    fi
    
    # Display first 20 videos
    local count=0
    while IFS= read -r line; do
        local video_title
        video_title=$(echo "$line" | jq -r '.title // "Unknown"')
        count=$((count + 1))
        printf "%2d. %s\n" "$count" "$video_title"
    done <<< "$videos"
    
    # Get total count
    local total_count
    total_count=$(echo "$videos" | wc -l | xargs)
    
    # Check if there are more videos (but don't wait too long)
    local full_count
    full_count=$(timeout 5 yt-dlp "https://youtube.com/playlist?list=$playlist_id" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        2>/dev/null | wc -l | xargs)
    
    if [ -n "$full_count" ] && [ "$full_count" -gt 20 ]; then
        echo ""
        echo "... and $((full_count - 20)) more videos"
        total_count=$full_count
    fi
    
    echo ""
    :
    echo "Total: $total_count videos in playlist"
    :
    
    # Cache the full result
    echo "$videos" > "$cache_file"
}

# Play entire playlist
play_playlist() {
    local playlist_id="$1"
    local playlist_title="$2"
    local audio_only="$3"
    local format sub_opts
    local url

    url="https://youtube.com/playlist?list=$playlist_id"

    # Set format based on audio-only flag
    if [ "$audio_only" = "true" ]; then
        format="bestaudio/best"
    else
        format="bestvideo[height<=${MAX_QUALITY}]+bestaudio/best"
    fi

    # Always fetch subtitles, visible when selected but no track selected by default (press 'j' to select)
    sub_opts="--ytdl-raw-options=write-subs=,write-auto-subs=,sub-lang=${SUB_LANG:-en} --slang=${SUB_LANG:-en} --sub-visibility=yes --sid=no"

    clear
    echo ""
    if [ "$audio_only" = "true" ]; then
        echo "playing playlist (audio)"
    else
        echo "playing playlist"
    fi
    echo "$playlist_title"
    echo ""
    sleep 2

    # Play playlist with mpv
    # shellcheck disable=SC2086
    if ! mpv "$url" \
        --ytdl-format="$format" \
        --volume="$VOLUME" \
        --autofit=1920x1080 \
        $sub_opts; then
        echo ""
        :
        echo "error:Playback failed"
        :
        return 1
    fi
    
    echo ""
    :
    echo "done:Playlist finished"
    :
    
    return 0
}

# Select video with fzf or return first result
select_video() {
    local search_term="$1"
    local auto_first="$2"
    local search_playlists="$3"
    local videos_count
    local selected
    
    # Count actual non-empty lines
    videos_count=$(echo "$results" | grep -c '^.')
    
    # If auto-first flag is set, return first result
    if [ "$auto_first" = "true" ]; then
        selected=$(echo "$results" | head -n 1)
        if [ -z "$selected" ]; then
            echo "error:No results found" >&2
            return 1
        fi
        echo "Auto-playing first result..." >&2
        echo "" >&2
        echo "$selected"
        return 0
    fi
    
    # Clear screen and show results (redirect to stderr to avoid capture)
    clear >&2
    echo "" >&2
    if [ "$search_playlists" = "true" ]; then
        echo "$search_term  ($videos_count playlists)" >&2
    else
        echo "$search_term  ($videos_count videos)" >&2
    fi
    echo "" >&2

    # Header
    local nav_header
    if [ "$SCREEN_READER_MODE" = "true" ]; then
        nav_header="j:down k:up ctrl-d:page-down ctrl-u:page-up enter:select q:quit"
    else
        nav_header="j/k:nav  enter:play  q:quit"
    fi
    
    # Different preview based on search mode
    if [ "$search_playlists" = "true" ]; then
        announce "Playlist selection menu ready. $videos_count playlists found."
        
        # For playlist mode, show playlist contents
        selected=$(echo "$results" | fzf $(get_fzf_base_opts) \
            --height=95% \
            --prompt="" \
            --header="$nav_header" \
            --preview="$0 --preview-playlist \$(echo {} | awk '{print \$NF}')" \
            --preview-window=right:60%:wrap \
            --info=inline \
            --bind=enter:accept \
            --tabstop=4)
    else
        announce "Video selection menu ready. $videos_count videos found."

        # For videos, show thumbnail
        selected=$(echo "$results" | fzf $(get_fzf_base_opts) \
            --height=95% \
            --prompt="" \
            --header="$nav_header" \
            --preview="video_id=\$(echo {} | awk '{print \$NF}'); if [ -f \"$CACHE_DIR/\$video_id.jpg\" ]; then chafa --format=kitty --size=60x30 \"$CACHE_DIR/\$video_id.jpg\" 2>/dev/null; else echo 'loading'; fi" \
            --preview-window=right:40%:wrap \
            --info=inline \
            --bind=enter:accept \
            --tabstop=4)
    fi

    if [ -z "$selected" ]; then
        echo "cancelled" >&2
        return 1
    fi
    
    echo "$selected"
    return 0
}

# Get related videos for a given video ID
get_related_videos() {
    local video_id="$1"
    local num_results="${2:-5}"
    
    echo "Finding related videos..." >&2
    
    # Use yt-dlp to get the video page and extract related video IDs
    # YouTube's related videos are in the page data
    local related_data
    related_data=$(timeout "$TIMEOUT" yt-dlp "https://youtube.com/watch?v=$video_id" \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-items 1 \
        2>/dev/null)
    
    if [ -z "$related_data" ]; then
        echo "error:Could not fetch related videos" >&2
        return 1
    fi
    
    # Try to extract channel info to get more videos from same channel
    local channel_id
    channel_id=$(echo "$related_data" | jq -r '.channel_id // empty')
    
    if [ -n "$channel_id" ]; then
        # Get latest videos from the same channel
        timeout "$TIMEOUT" yt-dlp "https://youtube.com/channel/$channel_id/videos" \
            --flat-playlist \
            --dump-json \
            --skip-download \
            --no-warnings \
            --quiet \
            --playlist-end "$num_results" \
            2>/dev/null | while IFS= read -r line; do
                local vid_id vid_title vid_duration vid_thumbnail
                vid_id=$(echo "$line" | jq -r '.id // empty')
                vid_title=$(echo "$line" | jq -r '.title // "Unknown"')
                vid_duration=$(echo "$line" | jq -r '.duration_string // "LIVE"')
                vid_thumbnail=$(echo "$line" | jq -r '.thumbnail // empty')
                
                # Skip if it's the same video
                if [ "$vid_id" != "$video_id" ] && [ -n "$vid_id" ]; then
                    echo "$vid_title"$'\t'"$vid_duration"$'\t'"$vid_id"$'\t'"$vid_thumbnail"
                fi
            done
        return 0
    fi
    
    return 1
}

# Fetch video description and metadata
get_video_info() {
    local video_id="$1"
    local cache_file="$VIDEO_INFO_CACHE_DIR/$video_id.json"
    
    # Check cache first
    if is_cache_valid "$cache_file"; then
        cat "$cache_file"
        return 0
    fi
    
    # Fetch from YouTube
    local video_info
    video_info=$(timeout "$TIMEOUT" yt-dlp "https://youtube.com/watch?v=$video_id" \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        2>/dev/null)
    
    # Cache the result if successful
    if [ -n "$video_info" ]; then
        echo "$video_info" > "$cache_file"
    fi
    
    echo "$video_info"
}

# Extract links from description with context
extract_links_from_description() {
    local description="$1"
    local tmpfile
    tmpfile=$(mktemp)
    
    # Extract URLs and try to get context (text before the URL)
    echo "$description" | grep -oE '.{0,40}https?://[^ ]+' | while IFS= read -r line; do
        # Extract the URL
        local url
        url=$(echo "$line" | grep -oE 'https?://[^ ]+')
        # Extract context (text before URL, cleaned up)
        local context
        context=$(echo "$line" | sed "s|$url||" | xargs)
        
        # If no context, try to infer from URL
        if [ -z "$context" ] || [ ${#context} -lt 3 ]; then
            context=$(echo "$url" | sed -E 's|https?://(www\.)?||' | cut -d'/' -f1)
        fi
        
        echo "$url"$'\t'"$context"
    done | awk '!seen[$1]++' > "$tmpfile"  # Remove duplicate URLs
    
    cat "$tmpfile"
    rm -f "$tmpfile"
}

# Show description and links in interactive selector
show_description_and_links() {
    local video_id="$1"
    local video_title="$2"
    
    echo "" >&2
    : >&2
    echo "üìÑ Fetching description and links..." >&2
    : >&2
    
    # Fetch video info
    local video_info
    video_info=$(get_video_info "$video_id")
    
    if [ -z "$video_info" ]; then
        echo "error:Could not fetch video information" >&2
        return 1
    fi
    
    # Extract description
    local description
    description=$(echo "$video_info" | jq -r '.description // "No description available"')
    
    # Extract links with context
    local links_file
    links_file=$(mktemp)
    extract_links_from_description "$description" > "$links_file"
    
    local link_count
    link_count=$(wc -l < "$links_file" | xargs)
    
    if [ "$link_count" -eq 0 ]; then
        echo "" >&2
        : >&2
        echo "No links found in description" >&2
        : >&2
        echo "" >&2
        echo "Description:" >&2
        echo "$description" | head -20 >&2
        echo "" >&2
        rm -f "$links_file"
        read -p "Press Enter to continue..." >&2
        return 0
    fi
    
    # Format links for fzf
    local formatted_links
    formatted_links=$(mktemp)
    while IFS=$'\t' read -r url context; do
        printf "%-60s  %s\n" "$url" "$context"
    done < "$links_file" > "$formatted_links"
    
    # Show interactive selector
    clear >&2
    echo "" >&2
    echo "$video_title" >&2
    echo "$link_count links" >&2
    echo "" >&2

    # Create a description preview file
    local desc_file
    desc_file=$(mktemp)
    : > "$desc_file"
    echo "description:" >> "$desc_file"
    echo "" >> "$desc_file"
    echo "$description" >> "$desc_file"

    # Run fzf with multi-select
    local selected
    selected=$(cat "$formatted_links" | fzf $(get_fzf_base_opts) \
        --multi \
        --height=95% \
        --prompt="" \
        --header="tab:select  enter:open  c:copy  q:quit" \
        --preview="cat $desc_file" \
        --preview-window=down:50%:wrap \
        --bind=tab:toggle+down \
        --bind='c:execute-silent(echo {} | awk "{print \$1}" | pbcopy)+abort' \
        --bind=a:select-all+accept \
        --info=inline)

    # Clean up temp files
    rm -f "$links_file" "$formatted_links" "$desc_file"

    if [ -z "$selected" ]; then
        return 0
    fi

    # Open selected links
    echo "$selected" | while IFS= read -r line; do
        local url
        url=$(echo "$line" | awk '{print $1}')
        open "$url" 2>/dev/null || xdg-open "$url" 2>/dev/null || echo "could not open: $url" >&2
        sleep 0.3
    done
    sleep 1
    
    return 0
}

# Get related playlists
get_related_playlists() {
    local playlist_id="$1"
    local num_results="${2:-3}"
    
    echo "Finding related playlists..." >&2
    
    # Get playlist info to extract channel or search similar content
    local playlist_data
    playlist_data=$(timeout "$TIMEOUT" yt-dlp "https://youtube.com/playlist?list=$playlist_id" \
        --dump-json \
        --flat-playlist \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-items 1 \
        2>/dev/null | head -n 1)
    
    if [ -z "$playlist_data" ]; then
        echo "error:Could not fetch playlist data" >&2
        return 1
    fi
    
    # Extract channel ID
    local channel_id
    channel_id=$(echo "$playlist_data" | jq -r '.channel_id // empty')
    
    if [ -n "$channel_id" ]; then
        # Get playlists from the same channel
        timeout "$TIMEOUT" yt-dlp "https://youtube.com/channel/$channel_id/playlists" \
            --flat-playlist \
            --dump-json \
            --skip-download \
            --no-warnings \
            --quiet \
            --playlist-end "$num_results" \
            2>/dev/null | while IFS= read -r line; do
                local pl_id pl_title pl_thumbnail
                pl_id=$(echo "$line" | jq -r '.id // empty')
                pl_title=$(echo "$line" | jq -r '.title // "Unknown"')
                pl_thumbnail=$(echo "$line" | jq -r '.thumbnails[0].url // empty')
                
                # Skip if it's the same playlist
                if [ "$pl_id" != "$playlist_id" ] && [ -n "$pl_id" ]; then
                    echo "$pl_title"$'\t'"PL"$'\t'"$pl_id"$'\t'"$pl_thumbnail"
                fi
            done
        return 0
    fi
    
    return 1
}

# Unified personal feed fetcher - consolidates home, subs, playlists, watch-later, liked
fetch_personal_feed() {
    local feed_type="$1"  # home, subs, playlists, watch-later, liked
    local auto_first="$2"
    
    # Map feed type to URL, icon, and description
    local feed_url feed_icon feed_desc error_msg is_playlist
    case "$feed_type" in
        home)
            feed_url="https://www.youtube.com/feed/recommended"
            feed_desc="recommendations"
            error_msg="no recommendations found"
            is_playlist=false
            ;;
        subs)
            feed_url="https://www.youtube.com/feed/subscriptions"
            feed_desc="subscriptions"
            error_msg="no subscription videos found"
            is_playlist=false
            ;;
        playlists)
            feed_url="https://www.youtube.com/feed/library"
            feed_desc="playlists"
            error_msg="no playlists found"
            is_playlist=true
            ;;
        watch-later)
            feed_url="https://www.youtube.com/playlist?list=WL"
            feed_desc="watch later"
            error_msg="watch later is empty"
            is_playlist=false
            ;;
        liked)
            feed_url="https://www.youtube.com/playlist?list=LL"
            feed_desc="liked videos"
            error_msg="no liked videos found"
            is_playlist=false
            ;;
        *)
            echo "error: unknown feed type: $feed_type"
            return 1
            ;;
    esac

    echo "loading $feed_desc..."
    echo ""
    
    local auth_args
    auth_args=$(get_auth_args) || return 1
    
    # Create temp file
    tmpfile=$(mktemp) || { echo "error:Failed to create temp file"; return 1; }
    
    # Determine how many results to fetch
    local num_to_fetch="$NUM_RESULTS"
    if [ "$auto_first" = "true" ]; then
        num_to_fetch=1
    fi
    
    echo "Loading your $feed_desc..."
    
    # Fetch feed content
    local jsonfile
    jsonfile=$(mktemp) || { echo "error:Failed to create temp file"; return 1; }
    
    # shellcheck disable=SC2086
    local error_file
    error_file=$(mktemp)
    if ! timeout "$TIMEOUT" yt-dlp $auth_args "$feed_url" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-end "$num_to_fetch" \
        2>"$error_file" > "$jsonfile"; then
        rm -f "$jsonfile"
        echo "error:Failed to fetch $feed_desc"
        echo ""
        
        # Show error details if available
        if [ -s "$error_file" ]; then
            echo "Error details:"
            head -10 "$error_file" | sed 's/^/  /'
            echo ""
        fi
        
        echo "Troubleshooting:"
        echo "  1. Make sure you're logged into YouTube in your browser"
        echo "  2. Close your browser completely and try again"
        echo "  3. Try running: yt-dlp $auth_args --simulate https://www.youtube.com/"
        echo ""
        rm -f "$error_file"
        return 1
    fi
    rm -f "$error_file"
    
    # Parse and display results
    local count=0
    while IFS= read -r line && [ "$count" -lt "$num_to_fetch" ]; do
        if [ "$is_playlist" = true ]; then
            # Parse as playlist
            local playlist_title playlist_id thumbnail
            playlist_title=$(echo "$line" | jq -r '.title // "Unknown"')
            playlist_id=$(echo "$line" | jq -r '.id // ""')
            thumbnail=$(echo "$line" | jq -r '.thumbnails[0].url // ""')
            
            if [ -n "$playlist_id" ] && [ "$playlist_id" != "null" ]; then
                echo "$playlist_title"$'\t'"PL"$'\t'"$playlist_id"$'\t'"$thumbnail" >> "$tmpfile"
                count=$((count + 1))
                echo "  $count/$num_to_fetch: $(echo "$playlist_title" | cut -c1-50)..."
            fi
        else
            # Parse as video
            local video_data
            video_data=$(echo "$line" | jq -r '"\(.title)\t\(.duration_string // "LIVE")\t\(.id)\t\(.thumbnail)"')
            
            if [ -n "$video_data" ]; then
                echo "$video_data" >> "$tmpfile"
                count=$((count + 1))
                echo "  $count/$num_to_fetch: $(echo "$line" | jq -r '.title' | cut -c1-50)..."
            fi
        fi
    done < "$jsonfile"
    
    # Debug: show what we got
    if [ ! -s "$jsonfile" ]; then
        echo "warning:Debug: No data received from yt-dlp"
        echo ""
        echo "This usually means:"
        echo "  1. Browser cookies are not accessible"
        echo "  2. Browser needs to be closed first"
        echo "  3. You're not logged into YouTube in your browser"
        echo ""
        echo "Try these steps:"
        echo "  1. Close $BROWSER completely"
        echo "  2. Make sure you're logged into YouTube in $BROWSER"
        echo "  3. Open $BROWSER, visit youtube.com, then close it"
        echo "  4. Run this command again"
        echo ""
        rm -f "$jsonfile"
        return 1
    fi
    
    rm -f "$jsonfile"
    echo ""
    
    if [ ! -s "$tmpfile" ] || [ "$count" -eq 0 ]; then
        echo "error:$error_msg"
        echo ""
        echo "Debug info:"
        echo "  - Browser: ${BROWSER:-not set}"
        echo "  - Feed URL: $feed_url"
        echo "  - Videos parsed: $count"
        echo ""
        echo "This might mean:"
        echo "  1. You don't have any content in this feed"
        echo "  2. Cookie authentication failed"
        echo ""
        return 1
    fi
    
    if [ "$is_playlist" = true ]; then
        echo "done:Successfully fetched $count playlists!"
    else
        echo "done:Successfully fetched $count videos!"
    fi
    echo ""
    
    return 0
}



# Fetch next videos from personal feed for autoplay
fetch_next_from_feed() {
    local feed_type="$1"  # home, subs, watch-later, liked
    local offset="${2:-0}"  # Skip first N videos
    local count="${3:-5}"  # How many to fetch
    
    local auth_args
    auth_args=$(get_auth_args) || return 1
    
    local feed_url
    case "$feed_type" in
        home)
            feed_url="https://www.youtube.com/feed/recommended"
            ;;
        subs)
            feed_url="https://www.youtube.com/feed/subscriptions"
            ;;
        watch-later)
            feed_url="https://www.youtube.com/playlist?list=WL"
            ;;
        liked)
            feed_url="https://www.youtube.com/playlist?list=LL"
            ;;
        *)
            return 1
            ;;
    esac
    
    # Fetch videos with offset
    local start=$((offset + 1))
    local end=$((offset + count))
    
    # shellcheck disable=SC2086
    timeout "$TIMEOUT" yt-dlp $auth_args "$feed_url" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-start "$start" \
        --playlist-end "$end" \
        2>/dev/null | while IFS= read -r line; do
            echo "$line" | jq -r '"\(.title)\t\(.duration_string // "LIVE")\t\(.id)\t\(.thumbnail)"'
        done
}

# Helper function to play selected content (video or playlist) with optional autoplay
play_selected_content() {
    local selected="$1"
    local search_playlists="$2"
    local audio_only="$3"
    local autoplay="$4"
    local personal_mode="$5"    # Optional
    local search_term="$6"       # Optional

    if [ "$search_playlists" = "true" ]; then
        local playlist_id playlist_title
        playlist_id=$(echo "$selected" | awk '{print $NF}')
        playlist_title=$(echo "$selected" | awk -F'\t' '{print $1}' | sed 's/^[[:space:]]*//' | xargs)

        if ! play_playlist "$playlist_id" "$playlist_title" "$audio_only"; then
            return 1
        fi

        # Autoplay if enabled
        if [ "$autoplay" = "true" ]; then
            autoplay_loop "playlist" "$playlist_id" "$audio_only" "$personal_mode" "$search_term"
        fi
    else
        if ! play_video "$selected" "$audio_only"; then
            return 1
        fi

        # Autoplay if enabled
        if [ "$autoplay" = "true" ]; then
            local video_id
            video_id=$(echo "$selected" | awk '{print $NF}')
            autoplay_loop "video" "$video_id" "$audio_only" "$personal_mode" "$search_term"
        fi
    fi

    return 0
}

# First-run tutorial and onboarding
show_first_run_tutorial() {
    clear
    :
    echo "üëã Welcome to yt - YouTube Terminal Browser!"
    :
    echo ""
    echo "This is your first time using yt. Let's take a quick tour!"
    echo ""
    echo "Press Enter to continue (or Ctrl+C to skip)..."
    read -r
    
    clear
    :
    echo "tutorial - basic search"
    :
    echo ""
    echo "Search for videos by typing:"
    echo "  yt <search term>"
    echo ""
    echo "Example:"
    echo "  yt lofi hip hop"
    echo "  yt vim tutorial"
    echo ""
    echo "Navigation (in the selection menu):"
    echo "  j/k     - Move down/up"
    echo "  Ctrl+d  - Page down"
    echo "  Ctrl+u  - Page up"
    echo "  Enter   - Play selected video"
    echo "  q/Esc   - Quit"
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    :
    echo "Tutorial - Quick Features"
    :
    echo ""
    echo "Useful flags:"
    echo "  -f, --first       Auto-play first result (no selection)"
    echo "  -a, --audio-only  Play audio only (save bandwidth)"
    echo "  -p, --playlist    Search for playlists instead"
    echo "  --no-autoplay     Disable autoplay feature"
    echo ""
    echo "Combine flags:"
    echo "  yt -af lofi music      # Audio-only, first result"
    echo "  yt -p study beats      # Search playlists"
    echo ""
    echo "Play from URL:"
    echo "  yt https://youtube.com/watch?v=..."
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    :
    echo "üë§ Tutorial - Personal Account Features"
    :
    echo ""
    echo "Access your YouTube account:"
    echo "  --home         Your personalized feed"
    echo "  --subs         Latest from subscriptions"
    echo "  --playlists    Your saved playlists"
    echo "  --watch-later  Watch later queue"
    echo "  --liked        Your liked videos"
    echo ""
    echo "Example:"
    echo "  yt --subs -a    # Subscriptions, audio-only"
    echo ""
    echo "Note: First use will prompt browser selection (one-time setup)"
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    :
    echo "tutorial - pro tips"
    :
    echo ""
    echo "1. Autoplay is ON by default"
    echo "   - Videos continue automatically (like YouTube)"
    echo "   - Press Ctrl+C during countdown to stop"
    echo ""
    echo "2. Smart caching"
    echo "   - Searches cached for 1 hour (instant results)"
    echo "   - Clear cache: yt --clear-cache"
    echo ""
    echo "3. Thumbnail previews"
    echo "   - Install 'chafa' for terminal thumbnails"
    echo "   - brew install chafa"
    echo ""
    echo "4. Get help anytime"
    echo "   - yt --help"
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    :
    echo "tutorial complete"
    :
    echo ""
    echo "Try it now with a sample search!"
    echo ""
    echo "Suggested searches:"
    echo "  1. yt lofi hip hop"
    echo "  2. yt -a relaxing music"
    echo "  3. yt -p chill beats"
    echo "  4. yt --home"
    echo ""
    echo -n "Would you like to try a sample search now? [y/N]: "
    read -r response
    
    # Mark tutorial as complete
    touch "$FIRST_RUN_FILE"
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        clear
        :
        echo "sample search: lofi hip hop"
        :
        echo ""
        
        # Override search term for tutorial
        TUTORIAL_SEARCH="lofi hip hop"
        return 0
    else
        clear
        :
        echo "done:Setup Complete!"
        :
        echo ""
        echo "Start using yt anytime by typing:"
        echo "  yt <search term>"
        echo ""
        echo "Run 'yt --help' to see all options."
        echo ""
        exit 0
    fi
}

# Check if first run
check_first_run() {
    if [ ! -f "$FIRST_RUN_FILE" ]; then
        return 0  # First run
    fi
    return 1  # Not first run
}

# Countdown with ability to cancel
countdown_autoplay() {
    local seconds="$1"
    local next_title="$2"

    echo ""
    echo "next: $next_title"
    echo ""

    for ((i=seconds; i>0; i--)); do
        echo -ne "\r  ${i}s  (ctrl+c to skip)  "
        sleep 1
    done
    echo ""

    return 0
}

# Unified autoplay loop - handles both videos and playlists
autoplay_loop() {
    local content_type="$1"  # "video" or "playlist"
    local current_id="$2"
    local audio_only="$3"
    local personal_mode="$4"  # Optional: for personal feeds
    local search_term="$5"    # Optional: for display

    local index=1  # Track position in personal feeds
    
    while true; do
        echo ""
        :
        if [ "$content_type" = "playlist" ]; then
            echo "done:Playlist finished"
        else
            echo "done:Video finished"
        fi
        :
        
        local next_item
        
        # Get next item based on type
        if [ "$content_type" = "playlist" ]; then
            next_item=$(get_related_playlists "$current_id" 1)
        else
            # For personal feeds, fetch next from same feed
            if [ -n "$personal_mode" ] && [ "$personal_mode" != "playlists" ]; then
                echo "Loading next from your $search_term..."
                next_item=$(fetch_next_from_feed "$personal_mode" "$index" 1)
                index=$((index + 1))
            else
                # For regular searches, use related videos
                next_item=$(get_related_videos "$current_id" 5 | head -n 1)
            fi
        fi
        
        if [ -z "$next_item" ]; then
            echo "error:No more content found"
            break
        fi
        
        # Parse next item based on type
        if [ "$content_type" = "playlist" ]; then
            local next_title next_id
            next_title=$(echo "$next_item" | cut -f1)
            next_id=$(echo "$next_item" | cut -f3)
            
            if ! countdown_autoplay 5 "$next_title"; then
                break
            fi
            
            current_id="$next_id"
            
            if ! play_playlist "$next_id" "$next_title" "$audio_only"; then
                echo "error:Failed to play next playlist"
                break
            fi
        else
            local next_title next_duration next_id next_thumbnail
            IFS=$'\t' read -r next_title next_duration next_id next_thumbnail <<< "$next_item"
            local next_selected
            next_selected=$(printf "%-80s [%8s] %s" "$next_title" "$next_duration" "$next_id")
            
            # Download thumbnail
            if [ -n "$next_thumbnail" ]; then
                curl -s "$next_thumbnail" -o "$CACHE_DIR/$next_id.jpg" 2>/dev/null &
            fi
            
            if ! countdown_autoplay 3 "$next_title"; then
                break
            fi
            
            current_id="$next_id"

            if ! play_video "$next_selected" "$audio_only"; then
                echo "error:Failed to play next video"
                break
            fi
        fi
    done
}

# Play selected video
play_video() {
    local selected="$1"
    local audio_only="$2"
    local video_id title url format sub_opts
    
    video_id=$(echo "$selected" | awk '{print $NF}')
    title=$(echo "$selected" | sed 's/\[.*\].*$//' | xargs)
    url="https://youtube.com/watch?v=$video_id"

    # Set format based on audio-only flag
    if [ "$audio_only" = "true" ]; then
        format="bestaudio/best"
    else
        format="bestvideo[height<=${MAX_QUALITY}]+bestaudio/best"
    fi

    # Always fetch subtitles, visible when selected but no track selected by default (press 'j' to select)
    sub_opts="--ytdl-raw-options=write-subs=,write-auto-subs=,sub-lang=${SUB_LANG:-en} --slang=${SUB_LANG:-en} --sub-visibility=yes --sid=no"

    # Show thumbnail before playing
    clear
    if command -v chafa &> /dev/null && [ -f "$CACHE_DIR/$video_id.jpg" ]; then
        if [ "$audio_only" = "true" ]; then
            echo "audio"
        else
            echo "video"
        fi
        echo ""
        chafa --format=kitty --size=60x30 "$CACHE_DIR/$video_id.jpg" 2>/dev/null
        echo ""
    fi

    echo ""
    if [ "$audio_only" = "true" ]; then
        echo "playing (audio)"
    else
        echo "playing"
    fi
    echo "$title"
    echo ""
    
    # Different behavior for audio-only vs video mode
    if [ "$audio_only" = "true" ]; then
        # AUDIO-ONLY MODE: Run MPV in foreground for full playback controls
        echo ""
        echo "Starting playback..."
        sleep 1
        
        # Run MPV in FOREGROUND - user has full MPV keyboard controls
        # shellcheck disable=SC2086
        if ! mpv "$url" \
            --ytdl-format="$format" \
            --volume="$VOLUME" \
            --autofit=1920x1080 \
            $sub_opts; then
            echo ""
            :
            echo "error:Playback failed"
            :
            return 1
        fi
        
        echo ""
        :
        echo "done:Playback finished"
        :
        
    else
        # VIDEO MODE: Run MPV in background, terminal listens for 'd' key
        echo ""
        echo "Starting playback..."
        sleep 1
        
        # Start MPV in BACKGROUND with output redirected to prevent terminal pollution
        # shellcheck disable=SC2086
        mpv "$url" \
            --ytdl-format="$format" \
            --volume="$VOLUME" \
            --autofit=1920x1080 \
            --really-quiet \
            --msg-level=all=error \
            $sub_opts \
            2>/dev/null &
        local mpv_pid=$!
        
        # Show interactive prompt while video is playing
        echo ""
        echo "playing..."
        echo ""
        echo "d:links  q:stop"
        echo ""
        
        # Listen for keypresses while MPV is running
        while kill -0 "$mpv_pid" 2>/dev/null; do
            # Read single character with timeout
            if read -t 1 -n 1 key 2>/dev/null; then
                case "$key" in
                    d|D)
                        # Send pause signal to MPV
                        kill -STOP "$mpv_pid" 2>/dev/null
                        
                        # Show description and links
                        show_description_and_links "$video_id" "$title"
                        
                        # Resume MPV
                        kill -CONT "$mpv_pid" 2>/dev/null
                        
                        # Redisplay prompt
                        echo ""
                        echo "Video still playing... Press 'd' for links, 'q' to stop"
                        ;;
                    q|Q)
                        # Kill MPV
                        echo ""
                        echo "Stopping playback..."
                        kill "$mpv_pid" 2>/dev/null
                        wait "$mpv_pid" 2>/dev/null
                        :
                        echo "stopped"
                        :
                        return 1
                        ;;
                esac
            fi
        done
        
        # Wait for MPV to finish
        wait "$mpv_pid" 2>/dev/null
        local mpv_exit=$?
        
        if [ "$mpv_exit" -ne 0 ]; then
            echo ""
            :
            echo "error:Playback failed"
            :
            return 1
        fi
        
        echo ""
        :
        echo "done:Playback finished"
        :
    fi
    
    return 0
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TUI MODE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

run_tui_mode() {
    # Toggle states
    local audio_on=false
    local first_on=false
    local playlist_on=false
    local saved_query=""

    # Get clipboard URL if valid YouTube link
    local clipboard_url
    clipboard_url=$(get_clipboard_youtube_url)

    # Main TUI loop
    while true; do
        # Build header showing current toggle states (ON bright white, off muted)
        local audio_display first_display playlist_display
        if [ "$audio_on" = true ]; then
            audio_display=$'\033[1;97mON\033[0m'
        else
            audio_display="off"
        fi
        if [ "$first_on" = true ]; then
            first_display=$'\033[1;97mON\033[0m'
        else
            first_display="off"
        fi
        if [ "$playlist_on" = true ]; then
            playlist_display=$'\033[1;97mON\033[0m'
        else
            playlist_display="off"
        fi

        local header="^a:audio($audio_display)  ^f:first($first_display)  ^p:playlist($playlist_display)"

        # Build menu items
        local menu_items=""
        if [ -n "$clipboard_url" ]; then
            menu_items="$clipboard_url"$'\n'
        fi
        menu_items+="Home"$'\n'
        menu_items+="Subscriptions"$'\n'
        menu_items+="Playlists"$'\n'
        menu_items+="Watch Later"$'\n'
        menu_items+="Liked Videos"

        # Run fzf with --expect to capture toggle keys
        local result
        result=$(echo -e "$menu_items" | FZF_DEFAULT_OPTS="" fzf \
            --layout=reverse \
            --no-border \
            --pointer=‚ñ∏ \
            --no-separator \
            --no-scrollbar \
            --color="$(get_fzf_colors)" \
            --ansi \
            --print-query \
            --query="$saved_query" \
            --expect=ctrl-a,ctrl-f,ctrl-p \
            --header="$header" \
            --prompt=": " \
            --no-info \
            --margin=1,2)

        local fzf_exit=$?

        # User cancelled with Esc/Ctrl+C
        if [ $fzf_exit -eq 130 ]; then
            return 0
        fi

        # Parse result: line 1 = query, line 2 = key pressed, line 3 = selection
        local query key selection
        query=$(echo "$result" | sed -n '1p')
        key=$(echo "$result" | sed -n '2p')
        selection=$(echo "$result" | sed -n '3p')

        # Handle toggle keys - update state and loop again (preserve query)
        case "$key" in
            ctrl-a)
                [ "$audio_on" = true ] && audio_on=false || audio_on=true
                saved_query="$query"
                continue
                ;;
            ctrl-f)
                [ "$first_on" = true ] && first_on=false || first_on=true
                saved_query="$query"
                continue
                ;;
            ctrl-p)
                [ "$playlist_on" = true ] && playlist_on=false || playlist_on=true
                saved_query="$query"
                continue
                ;;
        esac

        # No selection made
        if [ -z "$query" ] && [ -z "$selection" ]; then
            return 0
        fi

        # Build flags array based on toggle states
        local flags=()
        [ "$audio_on" = true ] && flags+=("--audio-only")
        [ "$first_on" = true ] && flags+=("--first")
        [ "$playlist_on" = true ] && flags+=("--playlist")

        # Determine action - prioritize selection if it's a menu item or URL
        if [ -n "$selection" ]; then
            # Check if selection is a known menu item
            case "$selection" in
                "Home")
                    main "${flags[@]}" "--home"
                    return $?
                    ;;
                "Subscriptions")
                    main "${flags[@]}" "--subs"
                    return $?
                    ;;
                "Playlists")
                    main "${flags[@]}" "--playlists"
                    return $?
                    ;;
                "Watch Later")
                    main "${flags[@]}" "--watch-later"
                    return $?
                    ;;
                "Liked Videos")
                    main "${flags[@]}" "--liked"
                    return $?
                    ;;
            esac

            # Check if selection is a YouTube URL (clipboard)
            if is_youtube_url "$selection"; then
                main "${flags[@]}" "$selection"
                return $?
            fi
        fi

        # No menu item selected - use query as search term
        if [ -n "$query" ]; then
            main "${flags[@]}" "$query"
            return $?
        fi

        return 0
    done
}

# Main function
main() {
    # Load configuration
    load_config

    # Handle internal preview mode (called by fzf)
    if [ "$1" = "--preview-playlist" ]; then
        preview_playlist "$2"
        exit 0
    fi

    # TUI mode: no arguments + interactive terminal
    if [ $# -eq 0 ] && [ -t 0 ] && [ -t 1 ]; then
        run_tui_mode
        exit $?
    fi

    # Parse flags
    local auto_first=false
    local audio_only=false
    local search_playlists=false
    local autoplay=true  # Autoplay is now DEFAULT
    local search_term=""
    local personal_mode=""  # me, home, subs, playlists, watch-later, liked
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --first)
                auto_first=true
                shift
                ;;
            --audio-only)
                audio_only=true
                shift
                ;;
            --playlist)
                search_playlists=true
                shift
                ;;
            --no-autoplay)
                autoplay=false
                shift
                ;;
            --home)
                personal_mode="home"
                shift
                ;;
            --subs)
                personal_mode="subs"
                shift
                ;;
            --playlists)
                personal_mode="playlists"
                shift
                ;;
            --watch-later)
                personal_mode="watch-later"
                shift
                ;;
            --liked)
                personal_mode="liked"
                shift
                ;;
            --high-contrast)
                HIGH_CONTRAST_MODE=true
                shift
                ;;
            --screen-reader)
                SCREEN_READER_MODE=true
                shift
                ;;
            --no-emojis)
                export NO_EMOJIS=true
                shift
                ;;
            --clear-cache)
                clear_cache
                exit 0
                ;;
            --setup-auth|--reconfigure)
                # Remove existing browser config and cookies, then re-run setup
                if [ -f "$CONFIG_FILE" ]; then
                    sed -i.bak '/^BROWSER=/d;/^AUTH_METHOD=/d' "$CONFIG_FILE"
                fi
                rm -f "$COOKIES_FILE"
                setup_authentication
                exit $?
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -*)
                # Handle combined short flags (e.g., -apf, -fap, etc.)
                # Check if it's a single dash followed by characters
                if [[ "$1" =~ ^-[a-z]+$ ]]; then
                    # Extract the flags without the leading dash
                    local flags="${1#-}"
                    # Process each character in the flag string
                    while [ -n "$flags" ]; do
                        local flag="${flags:0:1}"
                        flags="${flags:1}"
                        case "$flag" in
                            f)
                                auto_first=true
                                ;;
                            a)
                                audio_only=true
                                ;;
                            p)
                                search_playlists=true
                                ;;
                            h)
                                show_usage
                                exit 0
                                ;;
                            *)
                                echo "Unknown option: -$flag"
                                show_usage
                                exit 1
                                ;;
                        esac
                    done
                else
                    echo "Unknown option: $1"
                    show_usage
                    exit 1
                fi
                shift
                ;;
            *)
                search_term="$search_term $1"
                shift
                ;;
        esac
    done
    
    # Trim leading/trailing whitespace
    search_term=$(echo "$search_term" | xargs)
    
    # Check for first run before showing usage
    if [ -z "$search_term" ] && [ -z "$personal_mode" ]; then
        if check_first_run; then
            # First run - show tutorial
            if ! check_dependencies; then
                exit 1
            fi
            show_first_run_tutorial
            # If tutorial set TUTORIAL_SEARCH, use it
            if [ -n "$TUTORIAL_SEARCH" ]; then
                search_term="$TUTORIAL_SEARCH"
            else
                exit 0
            fi
        else
            # Not first run - show usage
            show_usage
            exit 1
        fi
    fi
    
    # Check dependencies (always run before usage to give helpful error messages)
    if ! check_dependencies; then
        exit 1
    fi
    
    # Handle personal mode
    if [ -n "$personal_mode" ]; then
        # Map personal mode to display name and fetch content
        case "$personal_mode" in
            home) search_term="Home" ;;
            subs) search_term="Subscriptions" ;;
            playlists) search_term="Your Playlists"; search_playlists=true ;;
            watch-later) search_term="Watch Later" ;;
            liked) search_term="Liked Videos" ;;
        esac
        
        # Fetch personal feed content
        if ! fetch_personal_feed "$personal_mode" "$auto_first"; then
            exit 1
        fi
        
        # Download thumbnails and format results
        if ! download_thumbnails "$search_playlists"; then
            exit 1
        fi
        
        # Select and play with unified function
        local selected
        if ! selected=$(select_video "$search_term" "$auto_first" "$search_playlists"); then
            exit 0
        fi
        
        if ! play_selected_content "$selected" "$search_playlists" "$audio_only" "$autoplay" "$personal_mode" "$search_term"; then
            exit 1
        fi
        
        exit 0
    fi
    
    # Check if input is a URL
    if [[ "$search_term" =~ ^https?:// ]]; then
        if ! play_url "$search_term" "$audio_only"; then
            exit 1
        fi
        exit 0
    fi
    
    # Search YouTube
    if ! search_youtube "$search_term" "$search_playlists" "$auto_first"; then
        exit 1
    fi
    
    # Download thumbnails and format results
    if ! download_thumbnails "$search_playlists"; then
        exit 1
    fi
    
    # Select and play content with unified function
    local selected
    if ! selected=$(select_video "$search_term" "$auto_first" "$search_playlists"); then
        exit 0
    fi
    
    if ! play_selected_content "$selected" "$search_playlists" "$audio_only" "$autoplay" "" "$search_term"; then
        exit 1
    fi
    
    exit 0
}

# Run main function
main "$@"
