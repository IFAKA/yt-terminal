#!/bin/bash
# YouTube terminal browser with detailed progress and thumbnails

set -o pipefail

VERSION="1.0.0"

# Spinner for loading states
show_spinner() {
    local pid=$1
    local message=$2
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local temp
    
    # Check if we have a terminal (for CI/non-interactive environments)
    if [ -t 1 ]; then
        tput civis 2>/dev/null  # Hide cursor
        
        while kill -0 "$pid" 2>/dev/null; do
            temp=${spinstr#?}
            printf "\r  ${C_CYAN}${spinstr:0:1}${C_RESET} ${C_WHITE}%s${C_RESET}" "$message"
            spinstr=$temp${spinstr%"$temp"}
            sleep 0.1
        done
        
        tput cnorm 2>/dev/null  # Show cursor
        printf "\r"
    else
        # Non-interactive mode: just show the message once
        echo "$message"
        wait "$pid"
    fi
}



# Default configuration
DEFAULT_NUM_RESULTS=10
DEFAULT_MAX_QUALITY=1080
DEFAULT_TIMEOUT=90
DEFAULT_VOLUME=100
DEFAULT_CACHE_DIR="$HOME/.cache/yt-thumbnails"
DEFAULT_SEARCH_CACHE_DIR="$HOME/.cache/yt-search"
DEFAULT_PLAYLIST_CACHE_DIR="$HOME/.cache/yt-playlists"
DEFAULT_VIDEO_INFO_CACHE_DIR="$HOME/.cache/yt-video-info"
DEFAULT_CACHE_EXPIRY=3600  # 1 hour in seconds
CONFIG_DIR="$HOME/.config/yt"
CONFIG_FILE="$CONFIG_DIR/config"
FIRST_RUN_FILE="$CONFIG_DIR/.first_run_complete"

# Accessibility settings
ACCESSIBILITY_MODE=${ACCESSIBILITY_MODE:-false}
HIGH_CONTRAST_MODE=${HIGH_CONTRAST_MODE:-false}
SCREEN_READER_MODE=${SCREEN_READER_MODE:-false}

# Load configuration
load_config() {
    # Set defaults
    NUM_RESULTS=${NUM_RESULTS:-$DEFAULT_NUM_RESULTS}
    MAX_QUALITY=${MAX_QUALITY:-$DEFAULT_MAX_QUALITY}
    TIMEOUT=${TIMEOUT:-$DEFAULT_TIMEOUT}
    VOLUME=${VOLUME:-$DEFAULT_VOLUME}
    CACHE_DIR=${CACHE_DIR:-$DEFAULT_CACHE_DIR}
    SEARCH_CACHE_DIR=${SEARCH_CACHE_DIR:-$DEFAULT_SEARCH_CACHE_DIR}
    PLAYLIST_CACHE_DIR=${PLAYLIST_CACHE_DIR:-$DEFAULT_PLAYLIST_CACHE_DIR}
    VIDEO_INFO_CACHE_DIR=${VIDEO_INFO_CACHE_DIR:-$DEFAULT_VIDEO_INFO_CACHE_DIR}
    CACHE_EXPIRY=${CACHE_EXPIRY:-$DEFAULT_CACHE_EXPIRY}
    
    # Create cache and config directories
    mkdir -p "$CACHE_DIR" "$SEARCH_CACHE_DIR" "$PLAYLIST_CACHE_DIR" "$VIDEO_INFO_CACHE_DIR" "$CONFIG_DIR" 2>/dev/null
    
    # Load user config if it exists
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
    
    # Auto-detect screen reader
    if command -v orca &> /dev/null || command -v espeak &> /dev/null || [ -n "$SCREEN_READER" ]; then
        SCREEN_READER_MODE=true
    fi
}

# Screen reader announcement
announce() {
    local message="$1"
    if [ "$SCREEN_READER_MODE" = "true" ]; then
        # Try different screen readers
        if command -v espeak &> /dev/null; then
            echo "$message" | espeak 2>/dev/null &
        elif command -v say &> /dev/null; then
            say "$message" 2>/dev/null &
        fi
    fi
    echo "$message" >&2
}

# ANSI Color codes for beautiful terminal output
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'

# Foreground colors
C_RED='\033[38;5;196m'
C_ORANGE='\033[38;5;208m'
C_YELLOW='\033[38;5;226m'
C_GREEN='\033[38;5;46m'
C_CYAN='\033[38;5;51m'
C_BLUE='\033[38;5;33m'
C_PURPLE='\033[38;5;141m'
C_MAGENTA='\033[38;5;201m'
C_PINK='\033[38;5;213m'
C_WHITE='\033[38;5;15m'
C_GRAY='\033[38;5;244m'

# YouTube brand colors
C_YT_RED='\033[38;5;196m'
C_YT_DARK='\033[38;5;235m'

# Gradient effects (using different shades)
C_GRAD1='\033[38;5;196m'  # Bright red
C_GRAD2='\033[38;5;202m'  # Red-orange
C_GRAD3='\033[38;5;208m'  # Orange
C_GRAD4='\033[38;5;214m'  # Yellow-orange
C_GRAD5='\033[38;5;220m'  # Yellow

# Get color scheme based on accessibility mode
get_fzf_colors() {
    if [ "$HIGH_CONTRAST_MODE" = "true" ]; then
        # High contrast: white on black with bright highlights
        echo "fg:#ffffff,bg:#000000,hl:#ffff00,fg+:#ffffff,bg+:#000000,hl+:#ffff00,border:#ffffff,prompt:#ffff00,pointer:#ffff00,marker:#00ff00,info:#00ffff,header:#ffffff"
    else
        # Modern YouTube-inspired theme with gradients
        echo "fg:#e0e0e0,bg:#0a0a0a,hl:#ff0000,fg+:#ffffff,bg+:#1a1a1a,hl+:#ff3333,border:#ff0000,prompt:#ff0000,pointer:#ff0000,marker:#00ff00,info:#00d9ff,header:#ff6b6b,gutter:#0a0a0a,scrollbar:#ff0000"
    fi
}

# Beautiful box drawing functions
draw_top_border() {
    local width="${1:-80}"
    echo -e "${C_YT_RED}â•”$(printf 'â•%.0s' $(seq 1 $((width - 2))))â•—${C_RESET}"
}

draw_bottom_border() {
    local width="${1:-80}"
    echo -e "${C_YT_RED}â•š$(printf 'â•%.0s' $(seq 1 $((width - 2))))â•${C_RESET}"
}

draw_middle_border() {
    local width="${1:-80}"
    echo -e "${C_YT_RED}â• $(printf 'â•%.0s' $(seq 1 $((width - 2))))â•£${C_RESET}"
}

draw_separator() {
    local width="${1:-80}"
    echo -e "${C_GRAY}$(printf 'â”€%.0s' $(seq 1 $width))${C_RESET}"
}

print_box_line() {
    local text="$1"
    local width="${2:-78}"
    local color="${3:-$C_WHITE}"
    local padding=$(( (width - ${#text}) / 2 ))
    local right_padding=$(( width - ${#text} - padding ))
    printf "${C_YT_RED}â•‘${C_RESET}%*s${color}%s${C_RESET}%*s${C_YT_RED}â•‘${C_RESET}\n" "$padding" "" "$text" "$right_padding" ""
}

print_box_line_left() {
    local text="$1"
    local width="${2:-78}"
    local padding="  "  # Left padding
    # Strip ANSI codes to get actual text length
    local stripped_text=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local text_len=${#stripped_text}
    local spaces_needed=$((width - text_len - 2))  # -2 for the padding
    printf "${C_YT_RED}â•‘${C_RESET}${padding}%b%*s${C_YT_RED}â•‘${C_RESET}\n" "$text" "$spaces_needed" ""
}

print_gradient_text() {
    local text="$1"
    local colors=("$C_GRAD1" "$C_GRAD2" "$C_GRAD3" "$C_GRAD4" "$C_GRAD5")
    local len=${#text}
    local colors_len=${#colors[@]}
    
    for ((i=0; i<len; i++)); do
        local color_idx=$((i * colors_len / len))
        echo -ne "${colors[$color_idx]}${text:$i:1}"
    done
    echo -e "${C_RESET}"
}

# Detect available browsers - simplified to let yt-dlp do the work
detect_browsers() {
    local browsers=("brave" "firefox" "chrome" "safari" "edge")
    local available=()
    
    for browser in "${browsers[@]}"; do
        # Test if yt-dlp can actually extract cookies from this browser
        if timeout 3 yt-dlp --cookies-from-browser "$browser" --simulate "https://youtube.com" &>/dev/null 2>&1; then
            available+=("$browser")
        fi
    done
    
    echo "${available[@]}"
}

# Setup authentication for personal content
setup_authentication() {
    clear
    draw_top_border 80
    print_box_line "" 78
    print_box_line "ğŸ”  AUTHENTICATION SETUP" 78 "$C_BOLD$C_CYAN"
    print_box_line "" 78
    draw_middle_border 80
    print_box_line "" 78
    print_box_line "To access personal content (subscriptions, playlists, etc.)," 78 "$C_WHITE"
    print_box_line "we need to use cookies from your browser." 78 "$C_WHITE"
    print_box_line "" 78
    print_box_line "This is safe and automatic - no passwords needed!" 78 "$C_GREEN"
    print_box_line "" 78
    draw_bottom_border 80
    echo ""
    
    # Detect available browsers
    local available_browsers
    mapfile -t available_browsers < <(detect_browsers)
    
    if [ ${#available_browsers[@]} -eq 0 ]; then
        echo "âŒ No supported browsers detected."
        echo ""
        echo "Supported browsers: Brave, Firefox, Chrome, Safari, Edge"
        echo ""
        echo "Please make sure you're logged into YouTube in one of these browsers."
        return 1
    fi
    
    echo "Detected browsers:"
    for i in "${!available_browsers[@]}"; do
        echo "  $((i+1)). ${available_browsers[$i]}"
    done
    echo ""
    
    # Auto-select if only one browser
    local browser_choice
    if [ ${#available_browsers[@]} -eq 1 ]; then
        browser_choice="${available_browsers[0]}"
        echo "Using ${browser_choice} (only browser detected)"
    else
        echo -n "Choose browser [1-${#available_browsers[@]}]: "
        read -r choice
        
        if [ -z "$choice" ] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#available_browsers[@]} ]; then
            echo "âŒ Invalid choice"
            return 1
        fi
        
        browser_choice="${available_browsers[$((choice-1))]}"
    fi
    
    echo ""
    echo "â³ Testing authentication with ${browser_choice}..."
    
    # Test if we can extract cookies
    if ! timeout 10 yt-dlp --cookies-from-browser "$browser_choice" --simulate "https://www.youtube.com/" &>/dev/null; then
        echo "âŒ Failed to extract cookies from ${browser_choice}"
        echo ""
        echo "Make sure:"
        echo "  1. You're logged into YouTube in ${browser_choice}"
        echo "  2. ${browser_choice} is not running (close it and try again)"
        return 1
    fi
    
    # Save to config
    {
        echo ""
        echo "# Authentication (auto-configured)"
        echo "AUTH_METHOD=\"browser\""
        echo "BROWSER=\"$browser_choice\""
    } >> "$CONFIG_FILE"
    
    # Reload config
    load_config
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ… Authentication configured!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Using: ${browser_choice} cookies"
    echo "Saved to: $CONFIG_FILE"
    echo ""
    
    return 0
}

# Get authentication arguments for yt-dlp
get_auth_args() {
    # Check if authentication is configured
    if [ -z "$BROWSER" ]; then
        # Not configured - run setup
        if ! setup_authentication; then
            return 1
        fi
    fi
    
    # Return the auth argument
    echo "--cookies-from-browser $BROWSER"
    return 0
}

# Generate cache key from search term
get_cache_key() {
    local search_term="$1"
    local search_type="$2"  # "video" or "playlist"
    echo "${search_type}_$(echo -n "$search_term" | md5)"
}

# Check if cache is valid (not expired)
is_cache_valid() {
    local cache_file="$1"
    
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    local current_time
    current_time=$(date +%s)
    local file_time
    file_time=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)
    local age=$((current_time - file_time))
    
    if [ "$age" -lt "$CACHE_EXPIRY" ]; then
        return 0
    else
        return 1
    fi
}

# Cleanup function for temp files
cleanup() {
    local exit_code=$?
    if [ -n "$tmpfile" ] && [ -f "$tmpfile" ]; then
        rm -f "$tmpfile"
    fi
    exit "$exit_code"
}

trap cleanup EXIT INT TERM

# Detect platform
detect_platform() {
    local os
    os=$(uname -s)
    
    case "$os" in
        Linux*)
            if grep -qi microsoft /proc/version 2>/dev/null; then
                echo "WSL"
            else
                echo "Linux"
            fi
            ;;
        Darwin*)
            echo "macOS"
            ;;
        MINGW*|MSYS*|CYGWIN*)
            echo "Windows"
            ;;
        *)
            echo "Unknown"
            ;;
    esac
}

# Get package manager
get_package_manager() {
    local platform="$1"
    
    case "$platform" in
        macOS)
            if command -v brew &> /dev/null; then
                echo "brew"
            else
                echo "none"
            fi
            ;;
        Linux|WSL)
            if command -v apt &> /dev/null; then
                echo "apt"
            elif command -v dnf &> /dev/null; then
                echo "dnf"
            elif command -v pacman &> /dev/null; then
                echo "pacman"
            elif command -v zypper &> /dev/null; then
                echo "zypper"
            else
                echo "none"
            fi
            ;;
        Windows)
            if command -v choco &> /dev/null; then
                echo "choco"
            elif command -v scoop &> /dev/null; then
                echo "scoop"
            else
                echo "none"
            fi
            ;;
        *)
            echo "none"
            ;;
    esac
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    local optional_deps=()
    local platform
    local pkg_manager
    
    platform=$(detect_platform)
    pkg_manager=$(get_package_manager "$platform")
    
    # Required dependencies
    command -v yt-dlp &> /dev/null || missing_deps+=("yt-dlp")
    command -v mpv &> /dev/null || missing_deps+=("mpv")
    command -v fzf &> /dev/null || missing_deps+=("fzf")
    command -v jq &> /dev/null || missing_deps+=("jq")
    command -v curl &> /dev/null || missing_deps+=("curl")
    
    # Optional dependencies
    command -v chafa &> /dev/null || optional_deps+=("chafa")
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âŒ Missing required dependencies"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "Please install the following:"
        for dep in "${missing_deps[@]}"; do
            echo "  â€¢ $dep"
        done
        echo ""
        echo "Detected platform: $platform"
        echo ""
        
        # Platform-specific installation instructions
        case "$pkg_manager" in
            brew)
                echo "Installation command (Homebrew):"
                echo "  brew install ${missing_deps[*]}"
                ;;
            apt)
                echo "Installation command (Debian/Ubuntu):"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
                
                if [ "$platform" = "WSL" ]; then
                    echo ""
                    echo "WSL Note: For video playback, you may need:"
                    echo "  â€¢ Windows mpv installed, or"
                    echo "  â€¢ X server (VcXsrv/Xming) for Linux GUI apps"
                fi
                ;;
            dnf)
                echo "Installation command (Fedora/RHEL):"
                echo "  sudo dnf install ${missing_deps[*]}"
                ;;
            pacman)
                echo "Installation command (Arch Linux):"
                echo "  sudo pacman -S ${missing_deps[*]}"
                ;;
            choco)
                echo "Installation command (Chocolatey):"
                echo "  choco install ${missing_deps[*]}"
                ;;
            scoop)
                echo "Installation command (Scoop):"
                echo "  scoop install ${missing_deps[*]}"
                ;;
            *)
                echo "Please install manually. Visit:"
                echo "  â€¢ yt-dlp: https://github.com/yt-dlp/yt-dlp#installation"
                echo "  â€¢ mpv: https://mpv.io/installation/"
                echo "  â€¢ fzf: https://github.com/junegunn/fzf#installation"
                echo "  â€¢ jq: https://stedolan.github.io/jq/download/"
                ;;
        esac
        echo ""
        return 1
    fi
    
    # Test if yt-dlp is working
    if ! timeout 10 yt-dlp --version &>/dev/null; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âŒ yt-dlp is not working properly"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "Try updating yt-dlp:"
        if command -v brew &> /dev/null; then
            echo "  brew upgrade yt-dlp"
        elif command -v pip3 &> /dev/null; then
            echo "  pip3 install --upgrade yt-dlp"
        elif command -v pip &> /dev/null; then
            echo "  pip install --upgrade yt-dlp"
        else
            echo "  Visit: https://github.com/yt-dlp/yt-dlp#installation"
        fi
        echo ""
        return 1
    fi
    
    if [ ${#optional_deps[@]} -ne 0 ]; then
        echo "â„¹ï¸  Optional: Install 'chafa' for thumbnail previews"
        echo "   brew install chafa"
        echo ""
    fi
    
    return 0
}

# Show usage information
show_usage() {
    echo "Usage: yt [OPTIONS] <search term>"
    echo ""
    echo "Search Options:"
    echo "  -f, --first        Auto-play first search result"
    echo "  -a, --audio-only   Play audio only (no video)"
    echo "  -p, --playlist     Search for playlists instead of videos"
    echo "  --no-autoplay      Disable autoplay (autoplay is ON by default)"
    echo ""
    echo "  Note: Short flags can be combined in any order (e.g., -apf, -fap, -pfa)"
    echo ""
    echo "Personal Account:"
    echo "  --home             View personalized recommendations"
    echo "  --subs             Browse latest videos from subscriptions"
    echo "  --playlists        Access your playlists"
    echo "  --watch-later      View watch later queue"
    echo "  --liked            Browse liked videos"
    echo ""
    echo "Accessibility Options:"
    echo "  --high-contrast    Enable high contrast mode"
    echo "  --screen-reader    Enable screen reader announcements"
    echo "  --no-emojis        Disable emoji icons (cleaner for some readers)"
    echo ""
    echo "Other Options:"
    echo "  --clear-cache      Clear search and playlist cache"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "Examples:"
    echo "  yt lofi beats                # Search, select, then autoplay related videos"
    echo "  yt -f lofi hip hop           # Auto-play first result, then autoplay"
    echo "  yt -a music                  # Audio-only with autoplay"
    echo "  yt -p lofi playlists         # Browse & autoplay playlists"
    echo "  yt -apf study music          # Chained: audio + playlist + first result"
    echo "  yt --no-autoplay vim tutorial # Play once and exit (no autoplay)"
    echo "  yt <url>                     # Play video from URL"
    echo ""
    echo "  yt --subs                    # Latest from subscriptions"
    echo "  yt --home -a                 # Recommendations in audio-only mode"
    echo ""
    echo "While Playing:"
    echo "  Video mode: Press 'd' to view description/links (video keeps playing)"
    echo "  Audio mode: Full MPV controls (pause, skip, volume, etc.)"
    echo "  Links can be opened in browser, copied, or selected multiple at once"
    echo ""
    echo "Autoplay:"
    echo "  Autoplay is ENABLED by default - videos/playlists continue automatically"
    echo "  After your selection plays, related content plays next (YouTube-style)"
    echo "  Press Ctrl+C during countdown to stop autoplay"
    echo ""
    echo "Authentication:"
    echo "  Personal features require browser cookies (Brave, Firefox, Chrome, etc.)"
    echo "  Setup runs automatically on first use - no passwords needed!"
    echo ""
    echo "Cache:"
    echo "  Search results are cached for $((CACHE_EXPIRY / 60)) minutes"
    echo "  Cache location: $SEARCH_CACHE_DIR"
    echo ""
    echo "Version: $VERSION"
    echo "Configuration file: $CONFIG_FILE"
}

# Clear cache
clear_cache() {
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ—‘ï¸  Clearing cache..."
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    
    local deleted=0
    
    if [ -d "$SEARCH_CACHE_DIR" ]; then
        local count
        count=$(find "$SEARCH_CACHE_DIR" -type f | wc -l | xargs)
        rm -rf "${SEARCH_CACHE_DIR:?}"/*
        deleted=$((deleted + count))
        echo "âœ“ Cleared search cache ($count files)"
    fi
    
    if [ -d "$PLAYLIST_CACHE_DIR" ]; then
        local count
        count=$(find "$PLAYLIST_CACHE_DIR" -type f | wc -l | xargs)
        rm -rf "${PLAYLIST_CACHE_DIR:?}"/*
        deleted=$((deleted + count))
        echo "âœ“ Cleared playlist cache ($count files)"
    fi
    
    if [ -d "$CACHE_DIR" ]; then
        local count
        count=$(find "$CACHE_DIR" -name "*.jpg" | wc -l | xargs)
        rm -rf "${CACHE_DIR:?}"/*.jpg
        deleted=$((deleted + count))
        echo "âœ“ Cleared thumbnail cache ($count files)"
    fi
    
    if [ -d "$VIDEO_INFO_CACHE_DIR" ]; then
        local count
        count=$(find "$VIDEO_INFO_CACHE_DIR" -type f | wc -l | xargs)
        rm -rf "${VIDEO_INFO_CACHE_DIR:?}"/*
        deleted=$((deleted + count))
        echo "âœ“ Cleared video info cache ($count files)"
    fi
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ… Cleared $deleted cached items"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# Play video from URL
play_url() {
    local url="$1"
    local audio_only="$2"
    local format
    
    if [ "$audio_only" = "true" ]; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸµ Playing audio from URL..."
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        format="bestaudio/best"
    else
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "â–¶ Playing video from URL..."
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        format="bestvideo[height<=${MAX_QUALITY}]+bestaudio/best"
    fi
    echo ""
    
    if ! mpv "$url" \
        --ytdl-format="$format" \
        --volume="$VOLUME" \
        --autofit=1920x1080; then
        echo "âŒ Error playing video"
        return 1
    fi
    
    return 0
}

# Unified YouTube search - handles both videos and playlists
search_youtube() {
    local search_term="$1"
    local search_playlists="$2"
    local auto_first="$3"
    
    # Set search parameters based on type
    local content_type content_icon search_url
    if [ "$search_playlists" = "true" ]; then
        content_type="playlist"
        content_icon="ğŸ“š"
        # URL-encode the search term
        local encoded_term
        encoded_term=$(echo "$search_term" | sed 's/ /+/g')
        search_url="https://www.youtube.com/results?search_query=${encoded_term}&sp=EgIQAw%253D%253D"
    else
        content_type="video"
        content_icon="ğŸ”"
        local num_to_fetch="$NUM_RESULTS"
        [ "$auto_first" = "true" ] && num_to_fetch=1
        search_url="ytsearch${num_to_fetch}:$search_term"
    fi
    
    if [ "$search_playlists" = "true" ]; then
        clear
        echo ""
        echo -e "${C_MAGENTA}${content_icon}  Searching playlists:${C_RESET} ${C_BOLD}${C_YELLOW}$search_term${C_RESET}"
        echo ""
    else
        clear
        echo ""
        echo -e "${C_YT_RED}${content_icon}  Searching:${C_RESET} ${C_BOLD}${C_YELLOW}$search_term${C_RESET}"
        echo ""
    fi
    
    # Create temp file
    tmpfile=$(mktemp) || { echo "âŒ Failed to create temp file"; return 1; }
    
    # Determine how many results to fetch
    local num_to_fetch="$NUM_RESULTS"
    if [ "$auto_first" = "true" ]; then
        num_to_fetch=1
    fi
    
    # Check cache first
    local cache_key
    cache_key=$(get_cache_key "$search_term" "$content_type")
    local cache_file="$SEARCH_CACHE_DIR/$cache_key.json"
    
    if is_cache_valid "$cache_file"; then
        echo -e "  ${C_CYAN}ğŸ“¦${C_RESET} ${C_WHITE}Loading from cache...${C_RESET}"
        cp "$cache_file" "$tmpfile"
        
        # Display cached results
        local count=0
        while IFS=$'\t' read -r title _ id _; do
            count=$((count + 1))
            echo -e "  ${C_GREEN}âœ“${C_RESET} Found ${C_YELLOW}($count/$num_to_fetch)${C_RESET}: ${C_WHITE}$(echo "$title" | cut -c1-60)${C_RESET}..."
            [ "$auto_first" = "true" ] && break
        done < "$tmpfile"
        echo ""
        return 0
    fi
    
    # Create temp file for raw JSON
    local jsonfile
    jsonfile=$(mktemp) || { echo "âŒ Failed to create temp file"; return 1; }
    
    # Fetch content
    local error_output
    error_output=$(mktemp)
    
    if [ "$search_playlists" = "true" ]; then
        echo "Searching playlists..."
        (
            timeout "$TIMEOUT" yt-dlp "$search_url" \
                --flat-playlist \
                --dump-json \
                --skip-download \
                --no-warnings \
                --quiet \
                --playlist-end "$num_to_fetch" \
                2>"$error_output" > "$jsonfile"
        ) &
    else
        echo "Searching YouTube..."
        (
            timeout "$TIMEOUT" yt-dlp "$search_url" \
                --dump-json \
                --skip-download \
                --no-warnings \
                --quiet \
                > "$jsonfile" 2>"$error_output"
        ) &
    fi
    local fetch_pid=$!
    
    # Show progress with count
    local progress_count=0
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local temp
    if [ -t 1 ]; then
        tput civis 2>/dev/null  # Hide cursor
        while kill -0 "$fetch_pid" 2>/dev/null; do
            if [ -f "$jsonfile" ]; then
                # Count lines starting with { and sanitize the result
                local count_raw
                count_raw=$(grep -c '^{' "$jsonfile" 2>/dev/null || echo "0")
                # Extract only the first number from the output (handle multi-line output)
                progress_count=$(echo "$count_raw" | head -1 | tr -cd '0-9' | grep -o '^[0-9]*' || echo "0")
                # Ensure we have a valid number
                [ -z "$progress_count" ] && progress_count=0
                # Cap at expected number (defensive check)
                [ "$progress_count" -gt "$num_to_fetch" ] && progress_count="$num_to_fetch"
            fi
            temp=${spinstr#?}
            local percent=$((progress_count * 100 / num_to_fetch))
            local bar_width=30
            local filled=$((percent * bar_width / 100))
            local bar=$(printf "%${filled}s" "" | tr ' ' 'â–ˆ')
            local empty=$(printf "%$((bar_width - filled))s" "" | tr ' ' 'â–‘')
            printf "\r  ${C_CYAN}${spinstr:0:1}${C_RESET} ${C_WHITE}Fetching %ss...${C_RESET} ${C_GREEN}${bar}${C_GRAY}${empty}${C_RESET} ${C_YELLOW}%d${C_RESET}/${C_WHITE}%d${C_RESET} ${C_DIM}(%d%%)${C_RESET}" "$content_type" "$progress_count" "$num_to_fetch" "$percent"
            spinstr=$temp${spinstr%"$temp"}
            sleep 0.2
        done
        tput cnorm 2>/dev/null  # Show cursor
        printf "\r"
    else
        echo "Fetching ${content_type}s from YouTube..."
        wait "$fetch_pid"
    fi
    
    wait "$fetch_pid" 2>/dev/null
    local fetch_result=$?
    
    if [ "$fetch_result" -ne 0 ]; then
        rm -f "$jsonfile"
        echo "âŒ Search failed or timed out"
        [ -s "$error_output" ] && echo "" && echo "Error details:" && head -3 "$error_output" | sed 's/^/  /' && echo ""
        echo "Troubleshooting steps:"
        echo "  1. Update yt-dlp (brew upgrade yt-dlp or pip install --upgrade yt-dlp)"
        echo "  2. Check your internet connection"
        echo "  3. Try a different search term"
        rm -f "$error_output"
        return 1
    fi
    
    rm -f "$error_output"
    
    # Parse and display results
    local count=0
    while IFS= read -r line && [ "$count" -lt "$num_to_fetch" ]; do
        if [ "$search_playlists" = "true" ]; then
            local playlist_title playlist_id thumbnail
            playlist_title=$(echo "$line" | jq -r '.title // "Unknown"')
            playlist_id=$(echo "$line" | jq -r '.id // ""')
            thumbnail=$(echo "$line" | jq -r '.thumbnails[0].url // ""')
            
            if [ -n "$playlist_id" ] && [ "$playlist_id" != "null" ]; then
                echo "$playlist_title"$'\t'"PL"$'\t'"$playlist_id"$'\t'"$thumbnail" >> "$tmpfile"
                count=$((count + 1))
                echo -e "  ${C_GREEN}âœ“${C_RESET} Found ${C_YELLOW}($count/$num_to_fetch)${C_RESET}: ${C_WHITE}$(echo "$playlist_title" | cut -c1-60)${C_RESET}..."
            fi
        else
            video_data=$(echo "$line" | jq -r '"\(.title)\t\(.duration_string // "LIVE")\t\(.id)\t\(.thumbnail)"')
            echo "$video_data" >> "$tmpfile"
            count=$((count + 1))
            echo -e "  ${C_GREEN}âœ“${C_RESET} Found ${C_YELLOW}($count/$num_to_fetch)${C_RESET}: ${C_WHITE}$(echo "$line" | jq -r '.title' | cut -c1-60)${C_RESET}..."
        fi
    done < "$jsonfile"
    
    rm -f "$jsonfile"
    echo ""
    
    if [ ! -s "$tmpfile" ] || [ "$count" -eq 0 ]; then
        echo "âŒ No ${content_type}s found!"
        return 1
    fi
    
    cp "$tmpfile" "$cache_file"
    return 0
}

# Download thumbnails
download_thumbnails() {
    local search_playlists="$1"
    results=""  # Initialize results variable
    mkdir -p "$CACHE_DIR" || { echo "âŒ Failed to create cache directory"; return 1; }
    
    while IFS=$'\t' read -r title duration id thumbnail; do
        if [ "$search_playlists" = "true" ]; then
            # Format playlist result line
            results="${results}$(printf "%-85s %s" "$title" "$id")"$'\n'
        else
            # Format video result line
            results="${results}$(printf "%-80s [%8s] %s" "$title" "$duration" "$id")"$'\n'
        fi
        
        # Download thumbnail in background for preview
        if [ -n "$thumbnail" ]; then
            curl -s "$thumbnail" -o "$CACHE_DIR/$id.jpg" 2>/dev/null &
        fi
    done < "$tmpfile"
    
    if [ -z "$results" ]; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âŒ No results found!"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        return 1
    fi
    
    # Count actual non-empty lines
    items_count=$(echo "$results" | grep -c '^.')
    if [ "$search_playlists" = "true" ]; then
        echo -e "  ${C_GREEN}âœ“${C_RESET} Successfully fetched ${C_BOLD}${C_YELLOW}$items_count${C_RESET} ${C_WHITE}playlists${C_RESET}"
    else
        echo -e "  ${C_GREEN}âœ“${C_RESET} Successfully fetched ${C_BOLD}${C_YELLOW}$items_count${C_RESET} ${C_WHITE}videos${C_RESET}"
    fi
    
    # Wait for thumbnails with spinner
    (sleep 2) &
    local sleep_pid=$!
    show_spinner "$sleep_pid" "Downloading thumbnails..."
    wait "$sleep_pid"
    
    echo -e "  ${C_GREEN}âœ“${C_RESET} ${C_WHITE}Ready!${C_RESET}"
    sleep 0.5
    
    return 0
}

# Preview playlist contents (for fzf preview)
preview_playlist() {
    local playlist_id="$1"
    
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ“š Playlist Contents"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    
    # Check cache first
    local cache_file="$PLAYLIST_CACHE_DIR/$playlist_id.json"
    
    if is_cache_valid "$cache_file"; then
        echo "ğŸ“¦ Cached playlist"
        echo ""
        
        # Read from cache
        local videos
        videos=$(cat "$cache_file")
        
        # Display first 20 videos
        local count=0
        while IFS= read -r line; do
            local video_title
            video_title=$(echo "$line" | jq -r '.title // "Unknown"')
            count=$((count + 1))
            printf "%2d. %s\n" "$count" "$video_title"
            [ "$count" -ge 20 ] && break
        done <<< "$videos"
        
        # Get total count
        local total_count
        total_count=$(echo "$videos" | wc -l | xargs)
        
        if [ "$total_count" -gt 20 ]; then
            echo ""
            echo "... and $((total_count - 20)) more videos"
        fi
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "Total: $total_count videos in playlist"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        return 0
    fi
    
    echo "â³ Loading videos..."
    echo ""
    
    # Fetch first 20 videos from playlist
    local videos
    videos=$(timeout 10 yt-dlp "https://youtube.com/playlist?list=$playlist_id" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-end 20 \
        2>/dev/null)
    
    if [ -z "$videos" ]; then
        echo "âŒ Could not load playlist contents"
        return 1
    fi
    
    # Display first 20 videos
    local count=0
    while IFS= read -r line; do
        local video_title
        video_title=$(echo "$line" | jq -r '.title // "Unknown"')
        count=$((count + 1))
        printf "%2d. %s\n" "$count" "$video_title"
    done <<< "$videos"
    
    # Get total count
    local total_count
    total_count=$(echo "$videos" | wc -l | xargs)
    
    # Check if there are more videos (but don't wait too long)
    local full_count
    full_count=$(timeout 5 yt-dlp "https://youtube.com/playlist?list=$playlist_id" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        2>/dev/null | wc -l | xargs)
    
    if [ -n "$full_count" ] && [ "$full_count" -gt 20 ]; then
        echo ""
        echo "... and $((full_count - 20)) more videos"
        total_count=$full_count
    fi
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "Total: $total_count videos in playlist"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # Cache the full result
    echo "$videos" > "$cache_file"
}

# Play entire playlist
play_playlist() {
    local playlist_id="$1"
    local playlist_title="$2"
    local audio_only="$3"
    local format
    local url
    
    url="https://youtube.com/playlist?list=$playlist_id"
    
    # Set format based on audio-only flag
    if [ "$audio_only" = "true" ]; then
        format="bestaudio/best"
    else
        format="bestvideo[height<=${MAX_QUALITY}]+bestaudio/best"
    fi
    
    clear
    echo ""
    if [ "$audio_only" = "true" ]; then
        echo -e "${C_BOLD}${C_CYAN}ğŸµ  Playing Playlist (Audio)${C_RESET}"
    else
        echo -e "${C_BOLD}${C_MAGENTA}ğŸ“š  Playing Playlist${C_RESET}"
    fi
    echo -e "${C_YELLOW}$playlist_title${C_RESET}"
    echo ""
    echo -e "${C_GRAY}Starting in 2 seconds...${C_RESET}"
    sleep 2
    
    # Play playlist with mpv
    if ! mpv "$url" \
        --ytdl-format="$format" \
        --volume="$VOLUME" \
        --autofit=1920x1080; then
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âŒ Playback failed"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        return 1
    fi
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ… Playlist finished"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    return 0
}

# Select video with fzf or return first result
select_video() {
    local search_term="$1"
    local auto_first="$2"
    local search_playlists="$3"
    local videos_count
    local selected
    
    # Count actual non-empty lines
    videos_count=$(echo "$results" | grep -c '^.')
    
    # If auto-first flag is set, return first result
    if [ "$auto_first" = "true" ]; then
        selected=$(echo "$results" | head -n 1)
        if [ -z "$selected" ]; then
            echo "âŒ No results found" >&2
            return 1
        fi
        echo "ğŸ¯ Auto-playing first result..." >&2
        echo "" >&2
        echo "$selected"
        return 0
    fi
    
    # Clear screen and show results (redirect to stderr to avoid capture)
    clear >&2
    echo "" >&2
    if [ "$search_playlists" = "true" ]; then
        echo -e "${C_PURPLE}ğŸ“š  Playlists:${C_RESET} ${C_BOLD}$search_term${C_RESET} ${C_GRAY}($videos_count results)${C_RESET}" >&2
    else
        echo -e "${C_YT_RED}ğŸ¥  Videos:${C_RESET} ${C_BOLD}$search_term${C_RESET} ${C_GRAY}($videos_count results)${C_RESET}" >&2
    fi
    echo "" >&2
    
    # Get appropriate color scheme
    local fzf_colors
    fzf_colors=$(get_fzf_colors)
    
    # Accessibility-friendly header
    local nav_header
    if [ "$SCREEN_READER_MODE" = "true" ]; then
        nav_header="Navigate: j down, k up, Ctrl-d page down, Ctrl-u page up, Enter select, q quit"
    else
        nav_header="[j/k] Navigate  â€¢  [Enter] Play  â€¢  [q] Quit"
    fi
    
    # Different preview based on search mode
    if [ "$search_playlists" = "true" ]; then
        announce "Playlist selection menu ready. $videos_count playlists found."
        
        # For playlist mode, show playlist contents
        selected=$(echo "$results" | fzf \
            --height=95% \
            --layout=reverse \
            --border=rounded \
            --border-label=" ğŸ“š Playlists " \
            --border-label-pos=3 \
            --prompt="â–¶ " \
            --header="$nav_header" \
            --preview="$0 --preview-playlist \$(echo {} | awk '{print \$NF}')" \
            --preview-window=right:60%:wrap:border-rounded \
            --preview-label=" Preview " \
            --color="$fzf_colors" \
            --pointer='â¯' \
            --marker='âœ“' \
            --separator='â”€' \
            --scrollbar='â”‚' \
            --info=inline \
            --bind 'j:down,k:up' \
            --bind 'ctrl-d:half-page-down,ctrl-u:half-page-up' \
            --bind 'ctrl-f:page-down,ctrl-b:page-up' \
            --bind 'q:abort' \
            --bind 'enter:accept' \
            --tabstop=4)
    else
        announce "Video selection menu ready. $videos_count videos found."
        
        # For videos, show thumbnail
        selected=$(echo "$results" | fzf \
            --height=95% \
            --layout=reverse \
            --border=rounded \
            --border-label=" ğŸ¬ Videos " \
            --border-label-pos=3 \
            --prompt="â–¶ " \
            --header="$nav_header" \
            --preview="video_id=\$(echo {} | awk '{print \$NF}'); if [ -f \"$CACHE_DIR/\$video_id.jpg\" ]; then chafa --format=kitty --size=60x30 \"$CACHE_DIR/\$video_id.jpg\" 2>/dev/null; else echo 'â³ Loading...'; fi" \
            --preview-window=right:40%:wrap:border-rounded \
            --preview-label=" Preview " \
            --color="$fzf_colors" \
            --pointer='â¯' \
            --marker='âœ“' \
            --separator='â”€' \
            --scrollbar='â”‚' \
            --info=inline \
            --bind 'j:down,k:up' \
            --bind 'ctrl-d:half-page-down,ctrl-u:half-page-up' \
            --bind 'ctrl-f:page-down,ctrl-b:page-up' \
            --bind 'q:abort' \
            --bind 'enter:accept' \
            --tabstop=4)
    fi
    
    if [ -z "$selected" ]; then
        echo "" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "âŒ Cancelled" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        return 1
    fi
    
    echo "$selected"
    return 0
}

# Get related videos for a given video ID
get_related_videos() {
    local video_id="$1"
    local num_results="${2:-5}"
    
    echo "â³ Finding related videos..." >&2
    
    # Use yt-dlp to get the video page and extract related video IDs
    # YouTube's related videos are in the page data
    local related_data
    related_data=$(timeout "$TIMEOUT" yt-dlp "https://youtube.com/watch?v=$video_id" \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-items 1 \
        2>/dev/null)
    
    if [ -z "$related_data" ]; then
        echo "âŒ Could not fetch related videos" >&2
        return 1
    fi
    
    # Try to extract channel info to get more videos from same channel
    local channel_id
    channel_id=$(echo "$related_data" | jq -r '.channel_id // empty')
    
    if [ -n "$channel_id" ]; then
        # Get latest videos from the same channel
        timeout "$TIMEOUT" yt-dlp "https://youtube.com/channel/$channel_id/videos" \
            --flat-playlist \
            --dump-json \
            --skip-download \
            --no-warnings \
            --quiet \
            --playlist-end "$num_results" \
            2>/dev/null | while IFS= read -r line; do
                local vid_id vid_title vid_duration vid_thumbnail
                vid_id=$(echo "$line" | jq -r '.id // empty')
                vid_title=$(echo "$line" | jq -r '.title // "Unknown"')
                vid_duration=$(echo "$line" | jq -r '.duration_string // "LIVE"')
                vid_thumbnail=$(echo "$line" | jq -r '.thumbnail // empty')
                
                # Skip if it's the same video
                if [ "$vid_id" != "$video_id" ] && [ -n "$vid_id" ]; then
                    echo "$vid_title"$'\t'"$vid_duration"$'\t'"$vid_id"$'\t'"$vid_thumbnail"
                fi
            done
        return 0
    fi
    
    return 1
}

# Fetch video description and metadata
get_video_info() {
    local video_id="$1"
    local cache_file="$VIDEO_INFO_CACHE_DIR/$video_id.json"
    
    # Check cache first
    if is_cache_valid "$cache_file"; then
        cat "$cache_file"
        return 0
    fi
    
    # Fetch from YouTube
    local video_info
    video_info=$(timeout "$TIMEOUT" yt-dlp "https://youtube.com/watch?v=$video_id" \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        2>/dev/null)
    
    # Cache the result if successful
    if [ -n "$video_info" ]; then
        echo "$video_info" > "$cache_file"
    fi
    
    echo "$video_info"
}

# Extract links from description with context
extract_links_from_description() {
    local description="$1"
    local tmpfile=$(mktemp)
    
    # Extract URLs and try to get context (text before the URL)
    echo "$description" | grep -oE '.{0,40}https?://[^ ]+' | while IFS= read -r line; do
        # Extract the URL
        local url=$(echo "$line" | grep -oE 'https?://[^ ]+')
        # Extract context (text before URL, cleaned up)
        local context=$(echo "$line" | sed "s|$url||" | xargs)
        
        # If no context, try to infer from URL
        if [ -z "$context" ] || [ ${#context} -lt 3 ]; then
            context=$(echo "$url" | sed -E 's|https?://(www\.)?||' | cut -d'/' -f1)
        fi
        
        echo "$url"$'\t'"$context"
    done | awk '!seen[$1]++' > "$tmpfile"  # Remove duplicate URLs
    
    cat "$tmpfile"
    rm -f "$tmpfile"
}

# Show description and links in interactive selector
show_description_and_links() {
    local video_id="$1"
    local video_title="$2"
    
    echo "" >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    echo "ğŸ“„ Fetching description and links..." >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    
    # Fetch video info
    local video_info
    video_info=$(get_video_info "$video_id")
    
    if [ -z "$video_info" ]; then
        echo "âŒ Could not fetch video information" >&2
        return 1
    fi
    
    # Extract description
    local description
    description=$(echo "$video_info" | jq -r '.description // "No description available"')
    
    # Extract links with context
    local links_file=$(mktemp)
    extract_links_from_description "$description" > "$links_file"
    
    local link_count
    link_count=$(wc -l < "$links_file" | xargs)
    
    if [ "$link_count" -eq 0 ]; then
        echo "" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "â„¹ï¸  No links found in description" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "" >&2
        echo "Description:" >&2
        echo "$description" | head -20 >&2
        echo "" >&2
        rm -f "$links_file"
        read -p "Press Enter to continue..." >&2
        return 0
    fi
    
    # Format links for fzf
    local formatted_links=$(mktemp)
    while IFS=$'\t' read -r url context; do
        printf "%-60s  %s\n" "$url" "$context"
    done < "$links_file" > "$formatted_links"
    
    # Show interactive selector
    clear >&2
    echo "" >&2
    echo -e "${C_BOLD}${C_CYAN}ğŸ”—  Links in Video${C_RESET}" >&2
    echo -e "${C_YELLOW}$video_title${C_RESET}" >&2
    echo -e "${C_GRAY}$link_count links found${C_RESET}" >&2
    echo "" >&2
    
    # Create a description preview file
    local desc_file=$(mktemp)
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" > "$desc_file"
    echo "Full Description:" >> "$desc_file"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> "$desc_file"
    echo "" >> "$desc_file"
    echo "$description" >> "$desc_file"
    
    # Get color scheme
    local fzf_colors
    fzf_colors=$(get_fzf_colors)
    
    # Run fzf with multi-select
    local selected
    selected=$(cat "$formatted_links" | fzf \
        --multi \
        --height=95% \
        --layout=reverse \
        --border=rounded \
        --border-label=" ğŸ”— Links " \
        --border-label-pos=3 \
        --prompt="â–¶ " \
        --header="[Tab] Select  â€¢  [Enter] Open  â€¢  [c] Copy  â€¢  [q] Cancel" \
        --preview="cat $desc_file" \
        --preview-window=down:50%:wrap:border-rounded \
        --preview-label=" Description " \
        --bind 'tab:toggle+down' \
        --bind 'c:execute-silent(echo {} | awk "{print \$1}" | pbcopy)+abort' \
        --bind "a:select-all+accept" \
        --color="$fzf_colors" \
        --pointer='â¯' \
        --marker='âœ“' \
        --separator='â”€' \
        --scrollbar='â”‚' \
        --info=inline)
    
    # Clean up temp files
    rm -f "$links_file" "$formatted_links" "$desc_file"
    
    if [ -z "$selected" ]; then
        return 0
    fi
    
    # Open selected links
    echo "" >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    echo "ğŸŒ Opening links..." >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    
    echo "$selected" | while IFS= read -r line; do
        local url=$(echo "$line" | awk '{print $1}')
        echo "  Opening: $url" >&2
        open "$url" 2>/dev/null || xdg-open "$url" 2>/dev/null || echo "  âš ï¸  Could not open: $url" >&2
        sleep 0.3  # Small delay between opening multiple links
    done
    
    echo "" >&2
    echo "âœ… Done!" >&2
    sleep 1
    
    return 0
}

# Get related playlists
get_related_playlists() {
    local playlist_id="$1"
    local num_results="${2:-3}"
    
    echo "â³ Finding related playlists..." >&2
    
    # Get playlist info to extract channel or search similar content
    local playlist_data
    playlist_data=$(timeout "$TIMEOUT" yt-dlp "https://youtube.com/playlist?list=$playlist_id" \
        --dump-json \
        --flat-playlist \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-items 1 \
        2>/dev/null | head -n 1)
    
    if [ -z "$playlist_data" ]; then
        echo "âŒ Could not fetch playlist data" >&2
        return 1
    fi
    
    # Extract channel ID
    local channel_id
    channel_id=$(echo "$playlist_data" | jq -r '.channel_id // empty')
    
    if [ -n "$channel_id" ]; then
        # Get playlists from the same channel
        timeout "$TIMEOUT" yt-dlp "https://youtube.com/channel/$channel_id/playlists" \
            --flat-playlist \
            --dump-json \
            --skip-download \
            --no-warnings \
            --quiet \
            --playlist-end "$num_results" \
            2>/dev/null | while IFS= read -r line; do
                local pl_id pl_title pl_thumbnail
                pl_id=$(echo "$line" | jq -r '.id // empty')
                pl_title=$(echo "$line" | jq -r '.title // "Unknown"')
                pl_thumbnail=$(echo "$line" | jq -r '.thumbnails[0].url // empty')
                
                # Skip if it's the same playlist
                if [ "$pl_id" != "$playlist_id" ] && [ -n "$pl_id" ]; then
                    echo "$pl_title"$'\t'"PL"$'\t'"$pl_id"$'\t'"$pl_thumbnail"
                fi
            done
        return 0
    fi
    
    return 1
}

# Unified personal feed fetcher - consolidates home, subs, playlists, watch-later, liked
fetch_personal_feed() {
    local feed_type="$1"  # home, subs, playlists, watch-later, liked
    local auto_first="$2"
    
    # Map feed type to URL, icon, and description
    local feed_url feed_icon feed_desc error_msg is_playlist
    case "$feed_type" in
        home)
            feed_url="https://www.youtube.com/feed/recommended"
            feed_icon="ğŸ "
            feed_desc="personalized recommendations"
            error_msg="No recommendations found!"
            is_playlist=false
            ;;
        subs)
            feed_url="https://www.youtube.com/feed/subscriptions"
            feed_icon="ğŸ“º"
            feed_desc="subscriptions feed"
            error_msg="No subscription videos found!"
            is_playlist=false
            ;;
        playlists)
            feed_url="https://www.youtube.com/feed/library"
            feed_icon="ğŸ“š"
            feed_desc="your playlists"
            error_msg="No playlists found!"
            is_playlist=true
            ;;
        watch-later)
            feed_url="https://www.youtube.com/playlist?list=WL"
            feed_icon="ğŸ•"
            feed_desc="watch later"
            error_msg="Watch later is empty!"
            is_playlist=false
            ;;
        liked)
            feed_url="https://www.youtube.com/playlist?list=LL"
            feed_icon="ğŸ‘"
            feed_desc="liked videos"
            error_msg="No liked videos found!"
            is_playlist=false
            ;;
        *)
            echo "âŒ Unknown feed type: $feed_type"
            return 1
            ;;
    esac
    
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "$feed_icon Fetching $feed_desc..."
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    
    local auth_args
    auth_args=$(get_auth_args) || return 1
    
    # Create temp file
    tmpfile=$(mktemp) || { echo "âŒ Failed to create temp file"; return 1; }
    
    # Determine how many results to fetch
    local num_to_fetch="$NUM_RESULTS"
    if [ "$auto_first" = "true" ]; then
        num_to_fetch=1
    fi
    
    echo "â³ Loading your $feed_desc..."
    
    # Fetch feed content
    local jsonfile
    jsonfile=$(mktemp) || { echo "âŒ Failed to create temp file"; return 1; }
    
    # shellcheck disable=SC2086
    if ! timeout "$TIMEOUT" yt-dlp $auth_args "$feed_url" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-end "$num_to_fetch" \
        2>/dev/null > "$jsonfile"; then
        rm -f "$jsonfile"
        echo "âŒ Failed to fetch $feed_desc"
        echo ""
        echo "Make sure you're logged into YouTube in your browser."
        return 1
    fi
    
    # Parse and display results
    local count=0
    while IFS= read -r line && [ "$count" -lt "$num_to_fetch" ]; do
        if [ "$is_playlist" = true ]; then
            # Parse as playlist
            local playlist_title playlist_id thumbnail
            playlist_title=$(echo "$line" | jq -r '.title // "Unknown"')
            playlist_id=$(echo "$line" | jq -r '.id // ""')
            thumbnail=$(echo "$line" | jq -r '.thumbnails[0].url // ""')
            
            if [ -n "$playlist_id" ] && [ "$playlist_id" != "null" ]; then
                echo "$playlist_title"$'\t'"PL"$'\t'"$playlist_id"$'\t'"$thumbnail" >> "$tmpfile"
                count=$((count + 1))
                echo "  âœ“ Found ($count/$num_to_fetch): $(echo "$playlist_title" | cut -c1-60)..."
            fi
        else
            # Parse as video
            local video_data
            video_data=$(echo "$line" | jq -r '"\(.title)\t\(.duration_string // "LIVE")\t\(.id)\t\(.thumbnail)"')
            
            if [ -n "$video_data" ]; then
                echo "$video_data" >> "$tmpfile"
                count=$((count + 1))
                echo "  âœ“ Found ($count/$num_to_fetch): $(echo "$line" | jq -r '.title' | cut -c1-60)..."
            fi
        fi
    done < "$jsonfile"
    
    rm -f "$jsonfile"
    echo ""
    
    if [ ! -s "$tmpfile" ] || [ "$count" -eq 0 ]; then
        echo "âŒ $error_msg"
        return 1
    fi
    
    if [ "$is_playlist" = true ]; then
        echo "âœ… Successfully fetched $count playlists!"
    else
        echo "âœ… Successfully fetched $count videos!"
    fi
    echo ""
    
    return 0
}

# Wrapper functions for backward compatibility
fetch_home_feed() { fetch_personal_feed "home" "$1"; }
fetch_subscriptions_feed() { fetch_personal_feed "subs" "$1"; }
fetch_user_playlists() { fetch_personal_feed "playlists" "$1"; }
fetch_watch_later() { fetch_personal_feed "watch-later" "$1"; }
fetch_liked_videos() { fetch_personal_feed "liked" "$1"; }

# Fetch next videos from personal feed for autoplay
fetch_next_from_feed() {
    local feed_type="$1"  # home, subs, watch-later, liked
    local offset="${2:-0}"  # Skip first N videos
    local count="${3:-5}"  # How many to fetch
    
    local auth_args
    auth_args=$(get_auth_args) || return 1
    
    local feed_url
    case "$feed_type" in
        home)
            feed_url="https://www.youtube.com/feed/recommended"
            ;;
        subs)
            feed_url="https://www.youtube.com/feed/subscriptions"
            ;;
        watch-later)
            feed_url="https://www.youtube.com/playlist?list=WL"
            ;;
        liked)
            feed_url="https://www.youtube.com/playlist?list=LL"
            ;;
        *)
            return 1
            ;;
    esac
    
    # Fetch videos with offset
    local start=$((offset + 1))
    local end=$((offset + count))
    
    # shellcheck disable=SC2086
    timeout "$TIMEOUT" yt-dlp $auth_args "$feed_url" \
        --flat-playlist \
        --dump-json \
        --skip-download \
        --no-warnings \
        --quiet \
        --playlist-start "$start" \
        --playlist-end "$end" \
        2>/dev/null | while IFS= read -r line; do
            echo "$line" | jq -r '"\(.title)\t\(.duration_string // "LIVE")\t\(.id)\t\(.thumbnail)"'
        done
}

# First-run tutorial and onboarding
show_first_run_tutorial() {
    clear
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ‘‹ Welcome to yt - YouTube Terminal Browser!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "This is your first time using yt. Let's take a quick tour!"
    echo ""
    echo "Press Enter to continue (or Ctrl+C to skip)..."
    read -r
    
    clear
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ“š Tutorial - Basic Search"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Search for videos by typing:"
    echo "  yt <search term>"
    echo ""
    echo "Example:"
    echo "  yt lofi hip hop"
    echo "  yt vim tutorial"
    echo ""
    echo "Navigation (in the selection menu):"
    echo "  j/k     - Move down/up"
    echo "  Ctrl+d  - Page down"
    echo "  Ctrl+u  - Page up"
    echo "  Enter   - Play selected video"
    echo "  q/Esc   - Quit"
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ¯ Tutorial - Quick Features"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Useful flags:"
    echo "  -f, --first       Auto-play first result (no selection)"
    echo "  -a, --audio-only  Play audio only (save bandwidth)"
    echo "  -p, --playlist    Search for playlists instead"
    echo "  --no-autoplay     Disable autoplay feature"
    echo ""
    echo "Combine flags:"
    echo "  yt -af lofi music      # Audio-only, first result"
    echo "  yt -p study beats      # Search playlists"
    echo ""
    echo "Play from URL:"
    echo "  yt https://youtube.com/watch?v=..."
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ‘¤ Tutorial - Personal Account Features"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Access your YouTube account:"
    echo "  --home         Your personalized feed"
    echo "  --subs         Latest from subscriptions"
    echo "  --playlists    Your saved playlists"
    echo "  --watch-later  Watch later queue"
    echo "  --liked        Your liked videos"
    echo ""
    echo "Example:"
    echo "  yt --subs -a    # Subscriptions, audio-only"
    echo ""
    echo "Note: First use will prompt browser selection (one-time setup)"
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ¨ Tutorial - Pro Tips"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "1. Autoplay is ON by default"
    echo "   - Videos continue automatically (like YouTube)"
    echo "   - Press Ctrl+C during countdown to stop"
    echo ""
    echo "2. Smart caching"
    echo "   - Searches cached for 1 hour (instant results)"
    echo "   - Clear cache: yt --clear-cache"
    echo ""
    echo "3. Thumbnail previews"
    echo "   - Install 'chafa' for terminal thumbnails"
    echo "   - brew install chafa"
    echo ""
    echo "4. Get help anytime"
    echo "   - yt --help"
    echo ""
    echo "Press Enter to continue..."
    read -r
    
    clear
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ¬ Tutorial Complete!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Try it now with a sample search!"
    echo ""
    echo "Suggested searches:"
    echo "  1. yt lofi hip hop"
    echo "  2. yt -a relaxing music"
    echo "  3. yt -p chill beats"
    echo "  4. yt --home"
    echo ""
    echo -n "Would you like to try a sample search now? [y/N]: "
    read -r response
    
    # Mark tutorial as complete
    touch "$FIRST_RUN_FILE"
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        clear
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸµ Sample Search: lofi hip hop"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        # Override search term for tutorial
        TUTORIAL_SEARCH="lofi hip hop"
        return 0
    else
        clear
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Setup Complete!"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "Start using yt anytime by typing:"
        echo "  yt <search term>"
        echo ""
        echo "Run 'yt --help' to see all options."
        echo ""
        exit 0
    fi
}

# Check if first run
check_first_run() {
    if [ ! -f "$FIRST_RUN_FILE" ]; then
        return 0  # First run
    fi
    return 1  # Not first run
}

# Countdown with ability to cancel
countdown_autoplay() {
    local seconds="$1"
    local next_title="$2"
    
    echo ""
    echo -e "${C_BOLD}${C_GREEN}â–¶  Next:${C_RESET} ${C_YELLOW}$next_title${C_RESET}"
    echo ""
    
    for ((i=seconds; i>0; i--)); do
        local bar_width=50
        local filled=$((bar_width - (i * bar_width / seconds)))
        local bar=$(printf "%${filled}s" "" | tr ' ' 'â–ˆ')
        local empty=$(printf "%$((bar_width - filled))s" "" | tr ' ' 'â–‘')
        echo -ne "\r  ${C_GREEN}${bar}${C_GRAY}${empty}${C_RESET}  ${C_BOLD}${i}s${C_RESET}  ${C_DIM}(Ctrl+C to skip)${C_RESET}  "
        sleep 1
    done
    echo -e "\n"
    
    return 0
}

# Play selected video
play_video() {
    local selected="$1"
    local audio_only="$2"
    local video_id title url format
    
    video_id=$(echo "$selected" | awk '{print $NF}')
    title=$(echo "$selected" | sed 's/\[.*\].*$//' | xargs)
    url="https://youtube.com/watch?v=$video_id"
    
    # Set format based on audio-only flag
    if [ "$audio_only" = "true" ]; then
        format="bestaudio/best"
    else
        format="bestvideo[height<=${MAX_QUALITY}]+bestaudio/best"
    fi
    
    # Show thumbnail before playing
    clear
    if command -v chafa &> /dev/null && [ -f "$CACHE_DIR/$video_id.jpg" ]; then
        if [ "$audio_only" = "true" ]; then
            draw_top_border 80
            print_box_line "" 78
            print_box_line "ğŸµ  AUDIO PREVIEW" 78 "$C_BOLD$C_CYAN"
            print_box_line "" 78
            draw_bottom_border 80
        else
            draw_top_border 80
            print_box_line "" 78
            print_box_line "â–¶ï¸  VIDEO PREVIEW" 78 "$C_BOLD$C_YT_RED"
            print_box_line "" 78
            draw_bottom_border 80
        fi
        echo ""
        chafa --format=kitty --size=60x30 "$CACHE_DIR/$video_id.jpg" 2>/dev/null
        echo ""
    fi
    
    if [ "$audio_only" = "true" ]; then
        echo ""
        echo -e "${C_BOLD}${C_CYAN}ğŸµ  Now Playing (Audio)${C_RESET}"
        echo -e "${C_YELLOW}$title${C_RESET}"
        echo ""
    else
        echo ""
        echo -e "${C_BOLD}${C_YT_RED}â–¶ï¸  Now Playing${C_RESET}"
        echo -e "${C_YELLOW}$title${C_RESET}"
        echo ""
    fi
    
    # Different behavior for audio-only vs video mode
    if [ "$audio_only" = "true" ]; then
        # AUDIO-ONLY MODE: Run MPV in foreground for full playback controls
        echo ""
        echo "Starting playback..."
        sleep 1
        
        # Run MPV in FOREGROUND - user has full MPV keyboard controls
        if ! mpv "$url" \
            --ytdl-format="$format" \
            --volume="$VOLUME" \
            --autofit=1920x1080; then
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âŒ Playback failed"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            return 1
        fi
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Playback finished"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        
    else
        # VIDEO MODE: Run MPV in background, terminal listens for 'd' key
        echo ""
        echo "Starting playback..."
        sleep 1
        
        # Start MPV in BACKGROUND with output redirected to prevent terminal pollution
        mpv "$url" \
            --ytdl-format="$format" \
            --volume="$VOLUME" \
            --autofit=1920x1080 \
            --really-quiet \
            --msg-level=all=error &
        local mpv_pid=$!
        
        # Show interactive prompt while video is playing
        echo ""
        echo -e "${C_GREEN}â–¶  Video playing${C_RESET}"
        echo ""
        echo -e "${C_CYAN}[d]${C_RESET} Description & links  â€¢  ${C_CYAN}[q]${C_RESET} Stop"
        echo ""
        
        # Listen for keypresses while MPV is running
        while kill -0 "$mpv_pid" 2>/dev/null; do
            # Read single character with timeout
            if read -t 1 -n 1 key 2>/dev/null; then
                case "$key" in
                    d|D)
                        # Send pause signal to MPV
                        kill -STOP "$mpv_pid" 2>/dev/null
                        
                        # Show description and links
                        show_description_and_links "$video_id" "$title"
                        
                        # Resume MPV
                        kill -CONT "$mpv_pid" 2>/dev/null
                        
                        # Redisplay prompt
                        echo ""
                        echo "Video still playing... Press 'd' for links, 'q' to stop"
                        ;;
                    q|Q)
                        # Kill MPV
                        echo ""
                        echo "Stopping playback..."
                        kill "$mpv_pid" 2>/dev/null
                        wait "$mpv_pid" 2>/dev/null
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        echo "â¹ï¸  Playback stopped"
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        return 1
                        ;;
                esac
            fi
        done
        
        # Wait for MPV to finish
        wait "$mpv_pid" 2>/dev/null
        local mpv_exit=$?
        
        if [ "$mpv_exit" -ne 0 ]; then
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âŒ Playback failed"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            return 1
        fi
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Playback finished"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    fi
    
    return 0
}

# Main function
main() {
    # Load configuration
    load_config
    
    # Handle internal preview mode (called by fzf)
    if [ "$1" = "--preview-playlist" ]; then
        preview_playlist "$2"
        exit 0
    fi
    
    # Parse flags
    local auto_first=false
    local audio_only=false
    local search_playlists=false
    local autoplay=true  # Autoplay is now DEFAULT
    local search_term=""
    local personal_mode=""  # me, home, subs, playlists, watch-later, liked
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --first)
                auto_first=true
                shift
                ;;
            --audio-only)
                audio_only=true
                shift
                ;;
            --playlist)
                search_playlists=true
                shift
                ;;
            --no-autoplay)
                autoplay=false
                shift
                ;;
            --home)
                personal_mode="home"
                shift
                ;;
            --subs)
                personal_mode="subs"
                shift
                ;;
            --playlists)
                personal_mode="playlists"
                shift
                ;;
            --watch-later)
                personal_mode="watch-later"
                shift
                ;;
            --liked)
                personal_mode="liked"
                shift
                ;;
            --high-contrast)
                HIGH_CONTRAST_MODE=true
                shift
                ;;
            --screen-reader)
                SCREEN_READER_MODE=true
                shift
                ;;
            --no-emojis)
                export NO_EMOJIS=true
                shift
                ;;
            --clear-cache)
                clear_cache
                exit 0
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -*)
                # Handle combined short flags (e.g., -apf, -fap, etc.)
                # Check if it's a single dash followed by characters
                if [[ "$1" =~ ^-[a-z]+$ ]]; then
                    # Extract the flags without the leading dash
                    local flags="${1#-}"
                    # Process each character in the flag string
                    while [ -n "$flags" ]; do
                        local flag="${flags:0:1}"
                        flags="${flags:1}"
                        case "$flag" in
                            f)
                                auto_first=true
                                ;;
                            a)
                                audio_only=true
                                ;;
                            p)
                                search_playlists=true
                                ;;
                            h)
                                show_usage
                                exit 0
                                ;;
                            *)
                                echo "Unknown option: -$flag"
                                show_usage
                                exit 1
                                ;;
                        esac
                    done
                else
                    echo "Unknown option: $1"
                    show_usage
                    exit 1
                fi
                shift
                ;;
            *)
                search_term="$search_term $1"
                shift
                ;;
        esac
    done
    
    # Trim leading/trailing whitespace
    search_term=$(echo "$search_term" | xargs)
    
    # Check for first run before showing usage
    if [ -z "$search_term" ] && [ -z "$personal_mode" ]; then
        if check_first_run; then
            # First run - show tutorial
            if ! check_dependencies; then
                exit 1
            fi
            show_first_run_tutorial
            # If tutorial set TUTORIAL_SEARCH, use it
            if [ -n "$TUTORIAL_SEARCH" ]; then
                search_term="$TUTORIAL_SEARCH"
            else
                exit 0
            fi
        else
            # Not first run - show usage
            show_usage
            exit 1
        fi
    fi
    
    # Check dependencies (always run before usage to give helpful error messages)
    if ! check_dependencies; then
        exit 1
    fi
    
    # Handle personal mode
    if [ -n "$personal_mode" ]; then
        
        # Fetch the appropriate content
        case "$personal_mode" in
            home)
                if ! fetch_home_feed "$auto_first"; then
                    exit 1
                fi
                search_term="Home"
                ;;
            subs)
                if ! fetch_subscriptions_feed "$auto_first"; then
                    exit 1
                fi
                search_term="Subscriptions"
                ;;
            playlists)
                if ! fetch_user_playlists "$auto_first"; then
                    exit 1
                fi
                search_playlists=true
                search_term="Your Playlists"
                ;;
            watch-later)
                if ! fetch_watch_later "$auto_first"; then
                    exit 1
                fi
                search_term="Watch Later"
                ;;
            liked)
                if ! fetch_liked_videos "$auto_first"; then
                    exit 1
                fi
                search_term="Liked Videos"
                ;;
        esac
        
        # Download thumbnails and format results
        if ! download_thumbnails "$search_playlists"; then
            exit 1
        fi
        
        # Select and play
        local selected
        if ! selected=$(select_video "$search_term" "$auto_first" "$search_playlists"); then
            exit 0
        fi
        
        # Handle playlist or video playback
        if [ "$search_playlists" = "true" ]; then
            local playlist_id playlist_title
            playlist_id=$(echo "$selected" | awk '{print $NF}')
            playlist_title=$(echo "$selected" | awk -F'\t' '{print $1}' | sed 's/^[[:space:]]*//' | xargs)
            
            if ! play_playlist "$playlist_id" "$playlist_title" "$audio_only"; then
                exit 1
            fi
            
            # Autoplay for playlists (same as regular playlist flow)
            if [ "$autoplay" = "true" ]; then
                while true; do
                    echo ""
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    echo "âœ… Playlist finished"
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    
                    local related_playlists
                    related_playlists=$(get_related_playlists "$playlist_id" 1)
                    
                    if [ -z "$related_playlists" ]; then
                        echo "âŒ No more related playlists found"
                        break
                    fi
                    
                    local next_playlist
                    next_playlist=$(echo "$related_playlists" | head -n 1)
                    
                    if [ -z "$next_playlist" ]; then
                        echo "âŒ No more related playlists found"
                        break
                    fi
                    
                    local next_pl_title next_pl_id
                    next_pl_title=$(echo "$next_playlist" | cut -f1)
                    next_pl_id=$(echo "$next_playlist" | cut -f3)
                    
                    if ! countdown_autoplay 5 "$next_pl_title"; then
                        break
                    fi
                    
                    playlist_id="$next_pl_id"
                    
                    if ! play_playlist "$next_pl_id" "$next_pl_title" "$audio_only"; then
                        echo "âŒ Failed to play next playlist"
                        break
                    fi
                done
            fi
        else
            # Play video
            if ! play_video "$selected" "$audio_only"; then
                exit 1
            fi
            
            # Autoplay for videos - use personalized feed for personal content
            if [ "$autoplay" = "true" ]; then
                local current_video_id
                current_video_id=$(echo "$selected" | awk '{print $NF}')
                local video_index=1  # Track position in feed
                
                while true; do
                    echo ""
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    echo "âœ… Video finished"
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    
                    local next_video
                    
                    # For personal feeds, fetch next from the same feed
                    if [ "$personal_mode" = "home" ] || [ "$personal_mode" = "subs" ] || \
                       [ "$personal_mode" = "watch-later" ] || [ "$personal_mode" = "liked" ]; then
                        echo "â³ Loading next from your $search_term..."
                        next_video=$(fetch_next_from_feed "$personal_mode" "$video_index" 1)
                        video_index=$((video_index + 1))
                    else
                        # For regular searches, use related videos
                        local related_videos
                        related_videos=$(get_related_videos "$current_video_id" 5)
                        next_video=$(echo "$related_videos" | head -n 1)
                    fi
                    
                    if [ -z "$next_video" ]; then
                        echo "âŒ No more videos found"
                        break
                    fi
                    
                    local next_title next_duration next_id next_thumbnail
                    IFS=$'\t' read -r next_title next_duration next_id next_thumbnail <<< "$next_video"
                    local next_selected
                    next_selected=$(printf "%-80s [%8s] %s" "$next_title" "$next_duration" "$next_id")
                    
                    if [ -n "$next_thumbnail" ]; then
                        curl -s "$next_thumbnail" -o "$CACHE_DIR/$next_id.jpg" 2>/dev/null &
                    fi
                    
                    if ! countdown_autoplay 3 "$next_title"; then
                        break
                    fi
                    
                    current_video_id="$next_id"
                    
                    if ! play_video "$next_selected" "$audio_only"; then
                        echo "âŒ Failed to play next video"
                        break
                    fi
                done
            fi
        fi
        
        exit 0
    fi
    
    # Check if input is a URL
    if [[ "$search_term" =~ ^https?:// ]]; then
        if ! play_url "$search_term" "$audio_only"; then
            exit 1
        fi
        exit 0
    fi
    
    # Search YouTube
    if ! search_youtube "$search_term" "$search_playlists" "$auto_first"; then
        exit 1
    fi
    
    # Download thumbnails and format results
    if ! download_thumbnails "$search_playlists"; then
        exit 1
    fi
    
    # Select video or playlist
    local selected
    if ! selected=$(select_video "$search_term" "$auto_first" "$search_playlists"); then
        exit 0
    fi
    
    # If playlist mode, play the selected playlist
    if [ "$search_playlists" = "true" ]; then
        local playlist_id playlist_title
        playlist_id=$(echo "$selected" | awk '{print $NF}')
        playlist_title=$(echo "$selected" | awk -F'\t' '{print $1}' | sed 's/^[[:space:]]*//' | xargs)
        
        if ! play_playlist "$playlist_id" "$playlist_title" "$audio_only"; then
            exit 1
        fi
        
        # If autoplay enabled, continue with related playlists
        if [ "$autoplay" = "true" ]; then
            while true; do
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "âœ… Playlist finished"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                
                # Get related playlists
                local related_playlists
                related_playlists=$(get_related_playlists "$playlist_id" 1)
                
                if [ -z "$related_playlists" ]; then
                    echo "âŒ No more related playlists found"
                    break
                fi
                
                # Get first related playlist
                local next_playlist
                next_playlist=$(echo "$related_playlists" | head -n 1)
                
                if [ -z "$next_playlist" ]; then
                    echo "âŒ No more related playlists found"
                    break
                fi
                
                # Extract playlist info
                local next_pl_title next_pl_id
                next_pl_title=$(echo "$next_playlist" | cut -f1)
                next_pl_id=$(echo "$next_playlist" | cut -f3)
                
                # Countdown before playing next
                if ! countdown_autoplay 5 "$next_pl_title"; then
                    break
                fi
                
                # Update current playlist ID for next iteration
                playlist_id="$next_pl_id"
                
                # Play next playlist
                if ! play_playlist "$next_pl_id" "$next_pl_title" "$audio_only"; then
                    echo "âŒ Failed to play next playlist"
                    break
                fi
            done
        fi
    else
        # Play single video
        if ! play_video "$selected" "$audio_only"; then
            exit 1
        fi
        
        # If autoplay enabled, continue with related videos
        if [ "$autoplay" = "true" ]; then
            local current_video_id
            current_video_id=$(echo "$selected" | awk '{print $NF}')
            
            while true; do
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "âœ… Video finished"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                
                # Get related videos
                local related_videos
                related_videos=$(get_related_videos "$current_video_id" 5)
                
                if [ -z "$related_videos" ]; then
                    echo "âŒ No more related videos found"
                    break
                fi
                
                # Get first related video
                local next_video
                next_video=$(echo "$related_videos" | head -n 1)
                
                if [ -z "$next_video" ]; then
                    echo "âŒ No more related videos found"
                    break
                fi
                
                # Format as selected video
                local next_title next_duration next_id next_thumbnail
                IFS=$'\t' read -r next_title next_duration next_id next_thumbnail <<< "$next_video"
                local next_selected
                next_selected=$(printf "%-80s [%8s] %s" "$next_title" "$next_duration" "$next_id")
                
                # Download thumbnail for next video
                if [ -n "$next_thumbnail" ]; then
                    curl -s "$next_thumbnail" -o "$CACHE_DIR/$next_id.jpg" 2>/dev/null &
                fi
                
                # Countdown before playing next
                if ! countdown_autoplay 3 "$next_title"; then
                    break
                fi
                
                # Update current video ID for next iteration
                current_video_id="$next_id"
                
                # Play next video
                if ! play_video "$next_selected" "$audio_only"; then
                    echo "âŒ Failed to play next video"
                    break
                fi
            done
        fi
    fi
    
    exit 0
}

# Run main function
main "$@"
